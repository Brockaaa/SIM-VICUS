<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<meta name="author" content="Andreas Nicolai">
<title>The NANDRAD CodeGenerator</title>
<style>
/* Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */

@import url(https://fonts.googleapis.com/css?family=Roboto+Condensed);
@import url(../css/asciidoctor.css); /* Default asciidoc style framework - important */

/* CUSTOMISATIONS */
/* Change the values in root for quick customisation. If you want even more fine grain... venture further. */

:root{
--maincolor:#FFFFFF;
--primarycolor:#a90e22;
--secondarycolor:#9f1d0b;
--tertiarycolor: #ededed;
--sidebarbackground:#CCC;
--linkcolor:#b71c1c;
--linkcoloralternate:#f44336;
--white:#FFFFFF;
--black:#000000;
}

/* Text styles */
body{font-family: "Roboto Condensed",sans-serif;}

h1,h2{color:var(--primarycolor) !important;font-family:"Roboto Condensed",sans-serif;}
h3,h4,h5,h6{color:var(--secondarycolor);font-family: "Roboto Condensed",sans-serif; }
.title{color:(--primarycolor) !important;font-family:"Roboto Condensed",sans-serif;font-style: normal; font-weight: normal;}
p{font-family: "Roboto Condensed",sans-serif ! important}
#toc.toc2 a{font-family:"Roboto Condensed",sans-serif;}
/*#toc.toc2 a:link{color:(--linkcolor) !important}
a:visited {color: #ffdbad;}
a.bare:visited {color: #204f83;}
a:hover {color: #317ed4;}
#toc.toc2 a:hover {color: #f1b464;}*/
/* code{background-color: var(--secondarycolor) !important;color:var(--white)} */
code,kbd,pre,samp{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;monospace;font-size:1em}

/* Table styles */
th{background-color: var(--tertiarycolor);color:var(--black) !important;}

#toctitle{color:var(--primarycolor);font-family: "Roboto Condensed",sans-serif;font-size: 1.6875em;}
#toc.toc2{background-color:#f4f8fd;}
/*#toc.toc2{background-color:#2C001E;color:white;}
#toc.toc2.a{color:white;}
*/

/* Responsiveness fixes */
video {
  max-width: 100%;
}

@media all and (max-width: 600px) {
table {
  width: 55vw!important;
  font-size: 3vw;
}

</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>The NANDRAD CodeGenerator</h1>
<div class="details">
<span id="author" class="author">Andreas Nicolai</span><br>
<span id="email" class="email"><a href="https://github.com/ghorwin" class="bare">https://github.com/ghorwin</a></span><br>
<span id="revnumber">version 1.1 (28.12.2022)</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#overview">1. Overview</a>
<ul class="sectlevel2">
<li><a href="#_how_does_it_work">1.1. How does it work?</a></li>
</ul>
</li>
<li><a href="#_functionality_example">2. Functionality Example</a>
<ul class="sectlevel2">
<li><a href="#_keyword_support">2.1. Keyword support</a></li>
<li><a href="#_keyword_definition_syntax">2.2. Keyword-definition syntax</a></li>
<li><a href="#_static_member_functions_of_class_keywordlist">2.3. Static member functions of class <code>KeywordList</code></a></li>
<li><a href="#_usage">2.4. Usage</a></li>
<li><a href="#cmake_automation">2.5. CMake automation</a></li>
</ul>
</li>
<li><a href="#_readwrite_to_xml_support_and_utility_macros">3. Read/write to XML support, and utility macros</a>
<ul class="sectlevel2">
<li><a href="#_supported_data_types">3.1. Supported data types</a></li>
<li><a href="#_readwrite_code">3.2. Read/write code</a>
<ul class="sectlevel3">
<li><a href="#_special_features">3.2.1. Special features</a></li>
<li><a href="#_naming_convention_for_xml_attributes_and_tag_names">3.2.2. Naming convention for XML attributes and tag names</a></li>
</ul>
</li>
<li><a href="#_utility_macros">3.3. Utility Macros</a>
<ul class="sectlevel3">
<li><a href="#_comparison_operator_macro">3.3.1. Comparison operator macro</a></li>
<li><a href="#xml_custom_readwrite">3.3.2. Custom read/write functionality</a></li>
<li><a href="#_only_writing_data_if_not_still_default_content">3.3.3. Only writing data if not still default content</a></li>
<li><a href="#_utility_macro_overview">3.3.4. Utility Macro Overview</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_specifications">4. Specifications</a>
<ul class="sectlevel2">
<li><a href="#command_line">4.1. Command line arguments for the code generator</a></li>
<li><a href="#_keyword_list_support">4.2. Keyword List Support</a></li>
<li><a href="#_keyword_parameters">4.3. Keyword Parameters</a></li>
<li><a href="#xml_serialization_rules">4.4. XML Serialization</a>
<ul class="sectlevel3">
<li><a href="#_idtype_variables">4.4.1. IDType variables</a></li>
<li><a href="#xml_complexTypes">4.4.2. Reading/writing custom complex types</a></li>
<li><a href="#_readingwriting_custom_complex_types_with_user_defined_tag_names">4.4.3. Reading/writing custom complex types with user-defined tag names</a></li>
<li><a href="#_handling_of_uninitialized_ids_nandradinvalid_id">4.4.4. Handling of uninitialized IDs (<code>= NANDRAD::INVALID_ID</code>)</a></li>
<li><a href="#_unsupported_data_member_types">4.4.5. Unsupported data member types</a></li>
<li><a href="#_xml_comments">4.4.6. XML Comments</a></li>
<li><a href="#_serialization_of_inherited_data_members">4.4.7. Serialization of inherited data members</a></li>
</ul>
</li>
<li><a href="#_ignoring_additional_class_declarations_in_same_header_file">4.5. Ignoring additional class declarations in same header file</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="overview">1. Overview</h2>
<div class="sectionbody">
<div class="paragraph">
<p>What is the NANDRAD-Code-Generator? Basically, it is a tool to parse NANDRAD header files, pick up lines with special comments and then generate code for:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>translating enumeration values into strings, descriptions, colors and units (very handy for physical parameter lists)</p>
</li>
<li>
<p>reading and writing xml data structures (elements and attributes) for designated member variables</p>
</li>
<li>
<p>comparing data structures with default instances (so that only modified members are written to file), and other utility functions</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Actually, the NANDRAD code generator is also used for the VICUS library. And the keyword list functionality is further used in the NandradSolver itself.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_how_does_it_work">1.1. How does it work?</h3>
<div class="paragraph">
<p>The code generator is called as part of the CMake build chain (see sections <a href="#command_line">command line options</a> and <a href="#cmake_automation">CMake Automation</a>). It detects changes in header files and then updates the respective generated files, including the file <code>NANDRAD_KeywordList.cpp</code>. It places the class-specific generated files into a subdirectory <code>ncg</code> (for <strong>N</strong>ANDRAD <strong>C</strong>ode <strong>G</strong>enerator files) where they are compiled just as any other cpp file of the project.</p>
</div>
<div class="paragraph">
<p>Since the generated code is plain C++ code, it can be parsed and debugged with any IDE just as regular code. Just remember:</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Any changes made to generated code will be overwritten!</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_functionality_example">2. Functionality Example</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_keyword_support">2.1. Keyword support</h3>
<div class="paragraph">
<p>You may have a class header, that looks as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">Interval</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="cm">/*! Parameters. */</span>
	<span class="k">enum</span> <span class="n">para_t</span> <span class="p">{</span>
		<span class="n">IP_START</span><span class="p">,</span>		<span class="c1">// Keyword: Start		[d] 'Start time point'</span>
		<span class="n">IP_END</span><span class="p">,</span>			<span class="c1">// Keyword: End			[d] 'End time point'</span>
		<span class="n">IP_STEPSIZE</span><span class="p">,</span>	<span class="c1">// Keyword: StepSize	[h] 'StepSize'</span>
		<span class="n">NUM_IP</span>
	<span class="p">};</span>

	<span class="p">...</span>

	<span class="cm">/*! The parameters defining the interval. */</span>
	<span class="n">IBK</span><span class="o">::</span><span class="n">Parameter</span>   <span class="n">m_para</span><span class="p">[</span><span class="n">NUM_IP</span><span class="p">];</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, you have a list of enumeration values. These are used to index one of the parameters in the member variable array <code>m_para</code>. In the code, you will use these enumerations like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">double</span> <span class="n">endtime</span> <span class="o">=</span> <span class="n">m_para</span><span class="p">[</span><span class="n">Interval</span><span class="o">::</span><span class="n">IP_END</span><span class="p">].</span><span class="n">value</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Sometimes, however, you need the keyword as a string, or need to get the unit written in the comment line. So, you write code like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// construct a parameter</span>
<span class="n">m_para</span><span class="p">[</span><span class="n">Interval</span><span class="o">::</span><span class="n">IP_END</span><span class="p">].</span><span class="n">set</span><span class="p">(</span>
        <span class="n">NANDRAD</span><span class="o">::</span><span class="n">KeywordList</span><span class="o">::</span><span class="n">Keyword</span><span class="p">(</span><span class="s">"Interval::para_t"</span><span class="p">,</span> <span class="n">Interval</span><span class="o">::</span><span class="n">IP_END</span><span class="p">),</span> <span class="c1">// the keyword is used as name</span>
        <span class="mi">24</span><span class="p">,</span> <span class="c1">// value</span>
        <span class="n">NANDRAD</span><span class="o">::</span><span class="n">KeywordList</span><span class="o">::</span><span class="n">Unit</span><span class="p">(</span><span class="s">"Interval::para_t"</span><span class="p">,</span> <span class="n">Interval</span><span class="o">::</span><span class="n">IP_END</span><span class="p">)</span> <span class="c1">// the unit</span>
    <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Normally, the unit is only meaningful for user interface representation, or when the value is printed to the user as default output/disply unit.</p>
</div>
<div class="paragraph">
<p>Also useful is the description, mostly in informative/error messages. Recommended would be:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">if</span> <span class="p">(</span><span class="n">condition_failed</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">IBK</span><span class="o">::</span><span class="n">IBK_Message</span><span class="p">(</span><span class="n">IBK</span><span class="o">::</span><span class="n">FormatString</span><span class="p">(</span><span class="s">"Parameter %1 (%2) is required."</span><span class="p">)</span>
        <span class="p">.</span><span class="n">arg</span><span class="p">(</span><span class="n">KeywordList</span><span class="o">::</span><span class="n">Keyword</span><span class="p">(</span><span class="s">"Interval::para_t"</span><span class="p">,</span> <span class="n">Interval</span><span class="o">::</span><span class="n">IP_END</span><span class="p">))</span>
        <span class="p">.</span><span class="n">arg</span><span class="p">(</span><span class="n">KeywordList</span><span class="o">::</span><span class="n">Description</span><span class="p">(</span><span class="s">"Interval::para_t"</span><span class="p">,</span> <span class="n">Interval</span><span class="o">::</span><span class="n">IP_END</span><span class="p">))</span> <span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Also, when parsing user data, for example from format:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="xml"><span class="nt">&lt;IBK:Parameter</span> <span class="na">name=</span><span class="s">"Start"</span> <span class="na">unit=</span><span class="s">"d"</span><span class="nt">&gt;</span>36<span class="nt">&lt;/IBK:Parameter&gt;</span>
<span class="nt">&lt;IBK:Parameter</span> <span class="na">name=</span><span class="s">"End"</span> <span class="na">unit=</span><span class="s">"d"</span><span class="nt">&gt;</span>72<span class="nt">&lt;/IBK:Parameter&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>You may need code like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">nameAttrib</span> <span class="o">=</span> <span class="n">getAttributeText</span><span class="p">(</span><span class="n">xmlTag</span><span class="p">,</span> <span class="s">"name"</span><span class="p">);</span> <span class="c1">// might be 'End'</span>

<span class="c1">// resolve enumeration value</span>
<span class="n">Interval</span><span class="o">::</span><span class="n">para_t</span> <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">Interval</span><span class="o">::</span><span class="n">para_t</span><span class="p">)</span><span class="n">KeywordList</span><span class="o">::</span><span class="n">Enumeration</span><span class="p">(</span><span class="s">"Interval::para_t"</span><span class="p">,</span> <span class="n">nameAttrib</span><span class="p">);</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_keyword_definition_syntax">2.2. Keyword-definition syntax</h3>
<div class="paragraph">
<p>The syntax for a keyword definition line is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>    SOME_ENUM_VALUE,	// Keyword: KEYWORD1 KEYWORD2  [unit] &lt;#FFEECC&gt; {defaultValue} 'description'</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>KEYWORD1</code> is the mandatory keyword, that should normally match the Enum-value, for example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>    ID_Category,        // Keyword: Category</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>KEYWORD2</code> is an optional (potential outdated) keyword. Unit, color (htmlcode), default value and description are all optional attributes.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Mind the separation chars. These must not appear inside other separation chars, so <code>[]&lt;&gt;{}</code> must not be used inside the description!</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The keyword list parser looks for occurances of exactly the substring  <code>// Keyword:</code>. So, if you merely comment out a line with a keyword, also falsify this substring, for example to <code>// ---Keyword:</code>. Otherwise the code-generator will still count the line and generate false enum value/keyword string mappings (and also potentially cause access violations/seg faults, because of invalid enum values being returned).</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_static_member_functions_of_class_keywordlist">2.3. Static member functions of class <code>KeywordList</code></h3>
<div class="paragraph">
<p>The code generator will now create the implementation of the functions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>KeywordList::Enumeration</code></p>
</li>
<li>
<p><code>KeywordList::Description</code></p>
</li>
<li>
<p><code>KeywordList::Keyword</code></p>
</li>
<li>
<p><code>KeywordList::Unit</code></p>
</li>
<li>
<p><code>KeywordList::Color</code> - meaningful for coloring types in user interfaces</p>
</li>
<li>
<p><code>KeywordList::DefaultValue</code> - can be used as default value in user interfaces</p>
</li>
<li>
<p><code>KeywordList::Count</code> - returns number of enumeration values in this category</p>
</li>
<li>
<p><code>KeywordList::KeywordExists</code> - convenience function, same as comparing result of <code>Enumeration()</code> with -1</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For optional parameters that are not provided, these functions return default values, i.e. empty strings, <code>IBK::Unit()</code> and 0 as default value.</p>
</div>
</div>
<div class="sect2">
<h3 id="_usage">2.4. Usage</h3>
<div class="paragraph">
<p>The header file <code>NANDRAD_KeywordList.h</code> is always the same and can be included directly. The corresponding implementation file <code>NANDRAD_KeywordList.cpp</code> is generated in the same directory as the NANDRAD header files.</p>
</div>
</div>
<div class="sect2">
<h3 id="cmake_automation">2.5. CMake automation</h3>
<div class="paragraph">
<p>The automatic update of the keyword list is triggered by a custom rule in the NANDRAD CMake project file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cmake"><span class="c1"># collect a list of all header files of the Nandrad library</span>
<span class="nb">file</span><span class="p">(</span> GLOB Nandrad_HDRS <span class="si">${</span><span class="nv">PROJECT_SOURCE_DIR</span><span class="si">}</span>/../../src/*.h <span class="p">)</span>

<span class="c1"># run the NandradCodeGenerator tool whenever the header files have changed</span>
<span class="c1"># to update the NANDRAD_KeywordList.h and NANDRAD_KeywordList.cpp file</span>
<span class="nb">add_custom_command</span> <span class="p">(</span>
	OUTPUT   <span class="si">${</span><span class="nv">PROJECT_SOURCE_DIR</span><span class="si">}</span>/../../src/NANDRAD_KeywordList.cpp
	DEPENDS  <span class="si">${</span><span class="nv">Nandrad_HDRS</span><span class="si">}</span> NandradCodeGenerator
	COMMAND  NandradCodeGenerator
	ARGS     NANDRAD <span class="si">${</span><span class="nv">PROJECT_SOURCE_DIR</span><span class="si">}</span>/../../src
<span class="p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>where <code>NandradCodeGenerator</code> is built as part of the tool chain as well. The rule has all header files as dependencies so that any change in any header file will result in a call to the code generator. The code generator will then create the file <code>NANDRAD_KeywordList.cpp</code>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_readwrite_to_xml_support_and_utility_macros">3. Read/write to XML support, and utility macros</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A second task for the code generator is to create functions for serialization of data structures to XML files. Hereby, the TinyXML-library is used.</p>
</div>
<div class="sect2">
<h3 id="_supported_data_types">3.1. Supported data types</h3>
<div class="paragraph">
<p>See section <a href="#xml_serialization_rules">XML Serialization</a> for a list and examples of supported data types.</p>
</div>
</div>
<div class="sect2">
<h3 id="_readwrite_code">3.2. Read/write code</h3>
<div class="paragraph">
<p>Since reading/writing XML code is pretty straight forward, much of this code writing can be generalized. Let&#8217;s take a look at a simple example.</p>
</div>
<div class="listingblock">
<div class="title">Class Sensor, with declarations of <code>readXML()</code> and <code>writeXML()</code> functions</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">Sensor</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="c1">// *** PUBLIC MEMBER FUNCTIONS ***</span>

	<span class="kt">void</span> <span class="n">readXML</span><span class="p">(</span><span class="k">const</span> <span class="n">TiXmlElement</span> <span class="o">*</span> <span class="n">element</span><span class="p">);</span>
	<span class="n">TiXmlElement</span> <span class="o">*</span> <span class="n">writeXML</span><span class="p">(</span><span class="n">TiXmlElement</span> <span class="o">*</span> <span class="n">parent</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

	<span class="c1">// *** PUBLIC MEMBER VARIABLES ***</span>

	<span class="cm">/*! Unique ID-number of the sensor.*/</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>						<span class="n">m_id</span> <span class="o">=</span> <span class="n">NANDRAD</span><span class="o">::</span><span class="n">INVALID_ID</span><span class="p">;</span>		<span class="c1">// XML:A:required</span>
	<span class="cm">/*! Name of the measured quantity */</span>
	<span class="n">std</span><span class="o">::</span><span class="n">string</span>							<span class="n">m_quantity</span><span class="p">;</span>						<span class="c1">// XML:E</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Since we use C++11 code, member variable initialization with the <code>=</code> assignment in header is ok and saves creating default constructors. Do this!</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The two members are written into file as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="xml"><span class="nt">&lt;Sensor</span> <span class="na">id=</span><span class="s">"12"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;Quantity&gt;</span>Temperature<span class="nt">&lt;/Quantity&gt;</span>
<span class="nt">&lt;/Sensor&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The implementation looks as follows:</p>
</div>
<div id="generated_readXML" class="listingblock">
<div class="title">Implementation of <code>Sensor::readXML()</code></div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">Sensor</span><span class="o">::</span><span class="n">readXML</span><span class="p">(</span><span class="k">const</span> <span class="n">TiXmlElement</span> <span class="o">*</span> <span class="n">element</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">FUNCID</span><span class="p">(</span><span class="n">Sensor</span><span class="o">::</span><span class="n">readXML</span><span class="p">);</span>

	<span class="k">try</span> <span class="p">{</span>
		<span class="c1">// search for mandatory attributes</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">TiXmlAttribute</span><span class="o">::</span><span class="n">attributeByName</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="s">"id"</span><span class="p">))</span>
			<span class="k">throw</span> <span class="n">IBK</span><span class="o">::</span><span class="n">Exception</span><span class="p">(</span> <span class="n">IBK</span><span class="o">::</span><span class="n">FormatString</span><span class="p">(</span><span class="n">XML_READ_ERROR</span><span class="p">).</span><span class="n">arg</span><span class="p">(</span><span class="n">element</span><span class="o">-&gt;</span><span class="n">Row</span><span class="p">()).</span><span class="n">arg</span><span class="p">(</span>
				<span class="n">IBK</span><span class="o">::</span><span class="n">FormatString</span><span class="p">(</span><span class="s">"Missing required 'id' attribute."</span><span class="p">)</span> <span class="p">),</span> <span class="n">FUNC_ID</span><span class="p">);</span>

		<span class="c1">// reading attributes</span>
		<span class="k">const</span> <span class="n">TiXmlAttribute</span> <span class="o">*</span> <span class="n">attrib</span> <span class="o">=</span> <span class="n">element</span><span class="o">-&gt;</span><span class="n">FirstAttribute</span><span class="p">();</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">attrib</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span> <span class="n">attribName</span> <span class="o">=</span> <span class="n">attrib</span><span class="o">-&gt;</span><span class="n">NameStr</span><span class="p">();</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">attribName</span> <span class="o">==</span> <span class="s">"id"</span><span class="p">)</span>
				<span class="n">m_id</span> <span class="o">=</span> <span class="n">readPODAttributeValue</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">attrib</span><span class="p">);</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">IBK</span><span class="o">::</span><span class="n">IBK_Message</span><span class="p">(</span><span class="n">IBK</span><span class="o">::</span><span class="n">FormatString</span><span class="p">(</span><span class="n">XML_READ_UNKNOWN_ATTRIBUTE</span><span class="p">).</span><span class="n">arg</span><span class="p">(</span><span class="n">attribName</span><span class="p">)</span>
				    <span class="p">.</span><span class="n">arg</span><span class="p">(</span><span class="n">element</span><span class="o">-&gt;</span><span class="n">Row</span><span class="p">()),</span> <span class="n">IBK</span><span class="o">::</span><span class="n">MSG_WARNING</span><span class="p">,</span> <span class="n">FUNC_ID</span><span class="p">,</span> <span class="n">IBK</span><span class="o">::</span><span class="n">VL_STANDARD</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">attrib</span> <span class="o">=</span> <span class="n">attrib</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">();</span>
		<span class="p">}</span>
		<span class="c1">// search for mandatory elements</span>
		<span class="c1">// reading elements</span>
		<span class="k">const</span> <span class="n">TiXmlElement</span> <span class="o">*</span> <span class="n">c</span> <span class="o">=</span> <span class="n">element</span><span class="o">-&gt;</span><span class="n">FirstChildElement</span><span class="p">();</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span> <span class="n">cName</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ValueStr</span><span class="p">();</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cName</span> <span class="o">==</span> <span class="s">"Quantity"</span><span class="p">)</span>
				<span class="n">m_quantity</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">GetText</span><span class="p">();</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">IBK</span><span class="o">::</span><span class="n">IBK_Message</span><span class="p">(</span><span class="n">IBK</span><span class="o">::</span><span class="n">FormatString</span><span class="p">(</span><span class="n">XML_READ_UNKNOWN_ELEMENT</span><span class="p">).</span><span class="n">arg</span><span class="p">(</span><span class="n">cName</span><span class="p">)</span>
				    <span class="p">.</span><span class="n">arg</span><span class="p">(</span><span class="n">element</span><span class="o">-&gt;</span><span class="n">Row</span><span class="p">()),</span> <span class="n">IBK</span><span class="o">::</span><span class="n">MSG_WARNING</span><span class="p">,</span> <span class="n">FUNC_ID</span><span class="p">,</span> <span class="n">IBK</span><span class="o">::</span><span class="n">VL_STANDARD</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">c</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">NextSiblingElement</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">catch</span> <span class="p">(</span><span class="n">IBK</span><span class="o">::</span><span class="n">Exception</span> <span class="o">&amp;</span> <span class="n">ex</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">throw</span> <span class="n">IBK</span><span class="o">::</span><span class="n">Exception</span><span class="p">(</span> <span class="n">ex</span><span class="p">,</span>
		    <span class="n">IBK</span><span class="o">::</span><span class="n">FormatString</span><span class="p">(</span><span class="s">"Error reading 'Sensor' element."</span><span class="p">),</span> <span class="n">FUNC_ID</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">catch</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">exception</span> <span class="o">&amp;</span> <span class="n">ex2</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">throw</span> <span class="n">IBK</span><span class="o">::</span><span class="n">Exception</span><span class="p">(</span> <span class="n">IBK</span><span class="o">::</span><span class="n">FormatString</span><span class="p">(</span><span class="s">"%1</span><span class="se">\n</span><span class="s">Error reading 'Sensor' element."</span><span class="p">)</span>
		    <span class="p">.</span><span class="n">arg</span><span class="p">(</span><span class="n">ex2</span><span class="p">.</span><span class="n">what</span><span class="p">()),</span> <span class="n">FUNC_ID</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In this function there is a lot of code that is repeated nearly identical in all files of the data model. For example, reading of attributes, converting them to number values (including error checking), testing for known child elements (and error handling) and the outer exception catch clauses. Similarly, this looks for the <code>writeXML()</code> function.</p>
</div>
<div class="listingblock">
<div class="title">Implementation of <code>Sensor::writeXML()</code></div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">TiXmlElement</span> <span class="o">*</span> <span class="n">Sensor</span><span class="o">::</span><span class="n">writeXML</span><span class="p">(</span><span class="n">TiXmlElement</span> <span class="o">*</span> <span class="n">parent</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
	<span class="n">TiXmlElement</span> <span class="o">*</span> <span class="n">e</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TiXmlElement</span><span class="p">(</span><span class="s">"Sensor"</span><span class="p">);</span>
	<span class="n">parent</span><span class="o">-&gt;</span><span class="n">LinkEndChild</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>

	<span class="n">e</span><span class="o">-&gt;</span><span class="n">SetAttribute</span><span class="p">(</span><span class="s">"id"</span><span class="p">,</span> <span class="n">IBK</span><span class="o">::</span><span class="n">val2string</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m_id</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">m_quantity</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
		<span class="n">TiXmlElement</span><span class="o">::</span><span class="n">appendSingleAttributeElement</span><span class="p">(</span><span class="n">e</span><span class="p">,</span>
		    <span class="s">"Quantity"</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(),</span> <span class="n">m_quantity</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">e</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In order for the code generator to create these two functions, we need to add some <em>annotations</em> to original class declaration:</p>
</div>
<div class="listingblock">
<div class="title">Class Sensor, with annotations for read/write code generation</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">Sensor</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="c1">// *** PUBLIC MEMBER FUNCTIONS ***</span>

	<span class="kt">void</span> <span class="n">readXML</span><span class="p">(</span><span class="k">const</span> <span class="n">TiXmlElement</span> <span class="o">*</span> <span class="n">element</span><span class="p">);</span>
	<span class="n">TiXmlElement</span> <span class="o">*</span> <span class="n">writeXML</span><span class="p">(</span><span class="n">TiXmlElement</span> <span class="o">*</span> <span class="n">parent</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

	<span class="c1">// *** PUBLIC MEMBER VARIABLES ***</span>

	<span class="cm">/*! Unique ID-number of the sensor.*/</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>						<span class="n">m_id</span> <span class="o">=</span> <span class="n">NANDRAD</span><span class="o">::</span><span class="n">INVALID_ID</span><span class="p">;</span>		<span class="c1">// XML:A:required</span>
	<span class="cm">/*! Name of the measured quantity */</span>
	<span class="n">std</span><span class="o">::</span><span class="n">string</span>							<span class="n">m_quantity</span><span class="p">;</span>						<span class="c1">// XML:E</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>// XML:A</code> says: make this an attribute. The <code>// XML:E</code> says: make this a child-element. The additional <code>required</code> keyword means: this attribute (or element) must be provided, otherwise <code>readXML()</code> will throw an exception.</p>
</div>
<div class="paragraph">
<p>The annotations can be used for quite a few data types. Rules for these are given in section <a href="#xml_serialization_rules">XML Serialization</a>.</p>
</div>
<div class="sect3">
<h4 id="_special_features">3.2.1. Special features</h4>
<div class="paragraph">
<p>There are a few special syntax forms supported by the code generator, see <a href="#xml_serialization_rules">XML Serialization</a> for details.</p>
</div>
</div>
<div class="sect3">
<h4 id="_naming_convention_for_xml_attributes_and_tag_names">3.2.2. Naming convention for XML attributes and tag names</h4>
<div class="paragraph">
<p>Note that attributes (XML:A) will always start with lowercase letter:
"m_idComponent" -&#8594; "idComponent"</p>
</div>
<div class="paragraph">
<p>while tag names (XML:E) will start with capital letter:
"m_idSurfaceHeating" -&#8594; "IdSurfaceHeating"</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_utility_macros">3.3. Utility Macros</h3>
<div class="paragraph">
<p>Since the declaration for the <code>readXML()</code> and <code>writeXML()</code> functions are always the same, we can avoid typing errors by using a define:</p>
</div>
<div class="listingblock">
<div class="title">Global code generator helpers</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="cp">#define NANDRAD_READWRITE \
	void readXML(const TiXmlElement * element); \
	TiXmlElement * writeXML(TiXmlElement * parent) const;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The header is now very short:</p>
</div>
<div class="listingblock">
<div class="title">Class Sensor, using code generator</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">Sensor</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="c1">// *** PUBLIC MEMBER FUNCTIONS ***</span>

	<span class="n">NANDRAD_READWRITE</span>

	<span class="c1">// *** PUBLIC MEMBER VARIABLES ***</span>

	<span class="cm">/*! Unique ID-number of the sensor.*/</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>						<span class="n">m_id</span> <span class="o">=</span> <span class="n">NANDRAD</span><span class="o">::</span><span class="n">INVALID_ID</span><span class="p">;</span>		<span class="c1">// XML:A:required</span>
	<span class="cm">/*! Name of the measured quantity */</span>
	<span class="n">std</span><span class="o">::</span><span class="n">string</span>							<span class="n">m_quantity</span><span class="p">;</span>						<span class="c1">// XML:E</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The implementation file <code>NANDRAD_Sensor.cpp</code> is no longer needed and can be removed.</p>
</div>
<div class="paragraph">
<p>The code generator will create a file: <code>ncg_NANDRAD_Sensor.cpp</code> with the functions <code>Sensor::readXML()</code> and <code>Sensor::writeXML()</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>To avoid regenerating (and recompiling) all <code>ncg_*</code> files whenever <em>one</em> header file is modified, the code generator inspects the file creation times of the <code>ncg_XXX.cpp</code> file with the latest modification/creation data of the respective <code>ncg_XXX.h</code> file. The code is only generated, if the header file is newer than the generated file.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_comparison_operator_macro">3.3.1. Comparison operator macro</h4>
<div class="paragraph">
<p>When checking if the content of an object is effectively the same as that of another (possibly freshly constructed) object, we need a comparison operator. Actually, we usually need both <code>operator==</code> and <code>operator!=</code> (depending on the alorithm used, either of the two is needed). The code for the class <code>Sensor</code> normally looks like that:</p>
</div>
<div class="listingblock">
<div class="title">Comparison operator (inequality)</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">bool</span> <span class="n">Sensor</span><span class="o">::</span><span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">Sensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">m_id</span> <span class="o">!=</span> <span class="n">other</span><span class="p">.</span><span class="n">m_id</span><span class="p">)</span>				<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">m_quantity</span> <span class="o">!=</span> <span class="n">other</span><span class="p">.</span><span class="n">m_quantity</span><span class="p">)</span>	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The other comparison operator is normally just implemented using the other:</p>
</div>
<div class="listingblock">
<div class="title">Comparison operator (equality)</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">Sensor</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="o">!</span><span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="n">other</span><span class="p">);</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The declaration and the definition of the equality operator can be replaced by a define:</p>
</div>
<div class="listingblock">
<div class="title">Global code generator helpers</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="cp">#define NANDRAD_COMP(X) \
	bool operator!=(const X &amp; other) const;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>So the class declaration becomes:</p>
</div>
<div class="listingblock">
<div class="title">Class Sensor, with comparison function declarations</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">Sensor</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="c1">// *** PUBLIC MEMBER FUNCTIONS ***</span>

	<span class="n">NANDRAD_READWRITE</span>
	<span class="n">NANDRAD_COMP</span><span class="p">(</span><span class="n">Sensor</span><span class="p">)</span>

	<span class="c1">// *** PUBLIC MEMBER VARIABLES ***</span>

	<span class="cm">/*! Unique ID-number of the sensor.*/</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>						<span class="n">m_id</span> <span class="o">=</span> <span class="n">NANDRAD</span><span class="o">::</span><span class="n">INVALID_ID</span><span class="p">;</span>		<span class="c1">// XML:A:required</span>
	<span class="cm">/*! Name of the measured quantity */</span>
	<span class="n">std</span><span class="o">::</span><span class="n">string</span>							<span class="n">m_quantity</span><span class="p">;</span>						<span class="c1">// XML:E</span>
<span class="p">};</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="xml_custom_readwrite">3.3.2. Custom read/write functionality</h4>
<div class="paragraph">
<p>Sometimes, the default read/write code is not enough, because something special needs to be written/read as well. Here, you can simply use an alternative define <code>NANDRAD_READWRITE_PRIVATE</code>:</p>
</div>
<div class="listingblock">
<div class="title">Global code generator helpers</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="cp">#define NANDRAD_READWRITE_PRIVATE \
	void readXMLPrivate(const TiXmlElement * element); \
	TiXmlElement * writeXMLPrivate(TiXmlElement * parent) const;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>which tells the code generator to generate the read/write code inside the <code>XXXPrivate</code>-functions.</p>
</div>
<div class="paragraph">
<p>You can now implement <code>readXML()</code> and <code>writeXML()</code> manually, hereby re-using the auto-generated functionality. Below is an example:</p>
</div>
<div class="listingblock">
<div class="title">Class Sensor, using code generator with private read/write functions</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">Sensor</span> <span class="p">{</span>
	<span class="n">NANDRAD_READWRITE_PRIVATE</span>
<span class="nl">public:</span>
	<span class="c1">// *** PUBLIC MEMBER FUNCTIONS ***</span>

	<span class="n">NANDRAD_READWRITE</span>
	<span class="n">NANDRAD_COMP</span><span class="p">(</span><span class="n">Sensor</span><span class="p">)</span>

	<span class="c1">// *** PUBLIC MEMBER VARIABLES ***</span>

	<span class="cm">/*! Unique ID-number of the sensor.*/</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>						<span class="n">m_id</span> <span class="o">=</span> <span class="n">NANDRAD</span><span class="o">::</span><span class="n">INVALID_ID</span><span class="p">;</span>		<span class="c1">// XML:A:required</span>
	<span class="cm">/*! Name of the measured quantity */</span>
	<span class="n">std</span><span class="o">::</span><span class="n">string</span>							<span class="n">m_quantity</span><span class="p">;</span>						<span class="c1">// XML:E</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Implementation file <code>NANDRAD_Sensor.cpp</code></div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">Sensor</span><span class="o">::</span><span class="n">readXML</span><span class="p">(</span><span class="k">const</span> <span class="n">TiXmlElement</span> <span class="o">*</span> <span class="n">element</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// simply reuse generated code</span>
	<span class="n">readXMLPrivate</span><span class="p">(</span><span class="n">element</span><span class="p">);</span>

	<span class="c1">// ... read other data from element</span>
<span class="p">}</span>


<span class="n">TiXmlElement</span> <span class="o">*</span> <span class="n">Sensor</span><span class="o">::</span><span class="n">writeXML</span><span class="p">(</span><span class="n">TiXmlElement</span> <span class="o">*</span> <span class="n">parent</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
	<span class="n">TiXmlElement</span> <span class="o">*</span> <span class="n">e</span> <span class="o">=</span> <span class="n">writeXMLPrivate</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>

	<span class="c1">// .... append other data to e</span>
	<span class="k">return</span> <span class="n">e</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_only_writing_data_if_not_still_default_content">3.3.3. Only writing data if not still default content</h4>
<div class="paragraph">
<p>To avoid writing empty tags or default values, you can write code like:</p>
</div>
<div class="listingblock">
<div class="title">Implementation of writeXML with default check</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">TiXmlElement</span> <span class="o">*</span> <span class="n">Sensor</span><span class="o">::</span><span class="n">writeXML</span><span class="p">(</span><span class="n">TiXmlElement</span> <span class="o">*</span> <span class="n">parent</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="c1">// check if we still have default data</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="k">this</span> <span class="o">==</span> <span class="n">Sensor</span><span class="p">())</span>
        <span class="k">return</span><span class="p">;</span> <span class="c1">// still default, do not write anything</span>

	<span class="n">TiXmlElement</span> <span class="o">*</span> <span class="n">e</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TiXmlElement</span><span class="p">(</span><span class="s">"Sensor"</span><span class="p">);</span>
	<span class="n">parent</span><span class="o">-&gt;</span><span class="n">LinkEndChild</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>

	<span class="n">e</span><span class="o">-&gt;</span><span class="n">SetAttribute</span><span class="p">(</span><span class="s">"id"</span><span class="p">,</span> <span class="n">IBK</span><span class="o">::</span><span class="n">val2string</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m_id</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">m_quantity</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
		<span class="n">TiXmlElement</span><span class="o">::</span><span class="n">appendSingleAttributeElement</span><span class="p">(</span><span class="n">e</span><span class="p">,</span>
		    <span class="s">"Quantity"</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(),</span> <span class="n">m_quantity</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">e</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>However, the code generator cannot write this automatically, because sometimes it is desired to write even default content. Also, a comparison-operator is not always available.</p>
</div>
<div class="paragraph">
<p>You can, however, use the macro <code>NANDRAD_READWRITE_IFNOTEMPTY(X)</code> instead of the regular <code>NANDRAD_READWRITE</code> macro for this:</p>
</div>
<div class="listingblock">
<div class="title">Macro with check for default values</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="cp">#define NANDRAD_READWRITE_IFNOTEMPTY(X) \
	void readXML(const TiXmlElement * element) { readXMLPrivate(element); } \
	TiXmlElement * writeXML(TiXmlElement * parent) const { if (*this != X()) return writeXMLPrivate(parent); else return nullptr; }</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Since this macro uses the functions <code>readXMLPrivate()</code> and <code>writeXMLPrivate()</code> you also need to tell the code generator to use the private function versions, as in the following example:</p>
</div>
<div class="listingblock">
<div class="title">Class Sensor, using code generator with private read/write functions and check to not write default data</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">Sensor</span> <span class="p">{</span>
	<span class="n">NANDRAD_READWRITE_PRIVATE</span>
<span class="nl">public:</span>
	<span class="c1">// *** PUBLIC MEMBER FUNCTIONS ***</span>

	<span class="n">NANDRAD_READWRITE_IFNOTEMPTY</span><span class="p">(</span><span class="n">Sensor</span><span class="p">)</span>
	<span class="n">NANDRAD_COMP</span><span class="p">(</span><span class="n">Sensor</span><span class="p">)</span>

	<span class="c1">// *** PUBLIC MEMBER VARIABLES ***</span>

	<span class="cm">/*! Unique ID-number of the sensor.*/</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>						<span class="n">m_id</span> <span class="o">=</span> <span class="n">NANDRAD</span><span class="o">::</span><span class="n">INVALID_ID</span><span class="p">;</span>		<span class="c1">// XML:A:required</span>
	<span class="cm">/*! Name of the measured quantity */</span>
	<span class="n">std</span><span class="o">::</span><span class="n">string</span>							<span class="n">m_quantity</span><span class="p">;</span>						<span class="c1">// XML:E</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>For classes such as <code>Sensor</code>, that define a member variable <code>m_id</code> which is initialized with <code>NANDRAD::INVALID_ID</code> it is also possible (and better) to use the macro <code>NANDRAD_READWRITE_IFNOT_INVALID_ID</code>, which does not require implementation of a comparison operator.</p>
</div>
<div class="listingblock">
<div class="title">Class Sensor, using code generator with private read/write functions and check to not write unused data objects</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">Sensor</span> <span class="p">{</span>
	<span class="n">NANDRAD_READWRITE_PRIVATE</span>
<span class="nl">public:</span>
	<span class="c1">// *** PUBLIC MEMBER FUNCTIONS ***</span>

	<span class="n">NANDRAD_READWRITE_IFNOT_INVALID_ID</span>

	<span class="c1">// *** PUBLIC MEMBER VARIABLES ***</span>

	<span class="cm">/*! Unique ID-number of the sensor.*/</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>						<span class="n">m_id</span> <span class="o">=</span> <span class="n">NANDRAD</span><span class="o">::</span><span class="n">INVALID_ID</span><span class="p">;</span>		<span class="c1">// XML:A:required</span>
	<span class="cm">/*! Name of the measured quantity */</span>
	<span class="n">std</span><span class="o">::</span><span class="n">string</span>							<span class="n">m_quantity</span><span class="p">;</span>						<span class="c1">// XML:E</span>
<span class="p">};</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_utility_macro_overview">3.3.4. Utility Macro Overview</h4>
<div class="listingblock">
<div class="title">All utility macros</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="cp">#define NANDRAD_READWRITE \
	void readXML(const TiXmlElement * element); \
	TiXmlElement * writeXML(TiXmlElement * parent) const;
</span>
<span class="cp">#define NANDRAD_READWRITE_IFNOTEMPTY(X) \
	void readXML(const TiXmlElement * element) { readXMLPrivate(element); } \
	TiXmlElement * writeXML(TiXmlElement * parent) const { if (*this != X()) return writeXMLPrivate(parent); else return nullptr; }
</span>
<span class="cp">#define NANDRAD_READWRITE_IFNOT_INVALID_ID \
	void readXML(const TiXmlElement * element) { readXMLPrivate(element); } \
	TiXmlElement * writeXML(TiXmlElement * parent) const { if (m_id != INVALID_ID) return writeXMLPrivate(parent); else return nullptr; }
</span>
<span class="cp">#define NANDRAD_READWRITE_PRIVATE \
	void readXMLPrivate(const TiXmlElement * element); \
	TiXmlElement * writeXMLPrivate(TiXmlElement * parent) const;
</span>
<span class="cp">#define NANDRAD_COMP(X) \
	bool operator!=(const X &amp; other) const; \
	bool operator==(const X &amp; other) const { return !operator!=(other); }
</span>
<span class="cp">#define NANDRAD_COMPARE_WITH_ID \
	bool operator==(unsigned int x) const { return m_id == x; }
</span>
<span class="cp">#define NANDRAD_COMPARE_WITH_NAME \
	bool operator==(const std::string &amp; name) const { return m_name == name; }
</span></code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>NANDRAD_READWRITE_IFNOTEMPTY</code> and <code>NANDRAD_READWRITE_IFNOTEMPTY</code> must be used in conjunction with <code>NANDRAD_READWRITE_PRIVATE</code>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_specifications">4. Specifications</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="command_line">4.1. Command line arguments for the code generator</h3>
<div class="paragraph">
<p>The code generator is called with the following syntax:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>SYNTAX:  NandradCodeGenerator &lt;namespace&gt; &lt;path/to/src&gt; &lt;generateQtSrc&gt; &lt;prefix&gt; &lt;ncg-dir&gt;
         &lt;namespace&gt; is usually NANDRAD (used also to compose file names).
         &lt;path/to/&lt;lib&gt;/src&gt; is + separated list of input directories to read the header files
         from.
         Keywordlist-source files are written into the first (or only) source directory.
         &lt;prefix&gt; is the file prefix &lt;prefix&gt;_KeywordList.cpp.
         &lt;generateQtSrc&gt; is 1 when Qt source should be generated, 0 otherwise.
         &lt;ncg-dir&gt; is the path to the directory where ncg_xxx.cpp files are written to.</pre>
</div>
</div>
<div class="paragraph">
<p>Running the code generator with argument <code>--help</code> prints this help page.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="bash"><span class="o">&gt;</span> NandradCodeGenerator NANDRAD ~/git/SIM-VICUS/externals/Nandrad/src 0 NANDRAD ncg</code></pre>
</div>
</div>
<div class="paragraph">
<p>or</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="bash"><span class="o">&gt;</span> NandradCodeGenerator NANDRAD_MODEL ~/git/SIM-VICUS/NandradSolver/src 0 NM ncg</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_keyword_list_support">4.2. Keyword List Support</h3>
<div class="paragraph">
<p>The parse requires fairly consistent code to be recognized, with the following rules. Look at the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
<span class="nl">public:</span>


    <span class="k">enum</span> <span class="n">parameterSet</span> <span class="p">{</span>
        <span class="n">PS_PARA1</span><span class="p">,</span>      <span class="c1">// Keyword: PARA1     'some lengthy description'</span>
        <span class="n">PS_PARA2</span><span class="p">,</span>      <span class="c1">// Keyword: PARA2     [K] &lt;#4512FF&gt; {273.15} 'A temperature parameter'</span>
        <span class="n">NUM_PS</span>
    <span class="p">}</span>

    <span class="k">enum</span> <span class="n">otherPara_t</span> <span class="p">{</span>
        <span class="n">OP_P1</span><span class="p">,</span>         <span class="c1">// Keyword: P1</span>
        <span class="n">OP_P2</span><span class="p">,</span>         <span class="c1">// Keyword: P2</span>
        <span class="n">OP_P3</span><span class="p">,</span>         <span class="c1">// Keyword: P3</span>
        <span class="n">NUM_OP</span>
    <span class="p">}</span>
<span class="p">...</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Here are the rules/conventions (how the parser operates):</p>
</div>
<div class="ulist">
<ul>
<li>
<p>a class scope is recognized by a string <code>class xxxx</code> (same line)</p>
</li>
<li>
<p>an enum scope is recognized by a string <code>enum yyyy</code> (same line)</p>
</li>
<li>
<p>a keyword specification is recognized by the string <code>// Keyword:</code> (with space between <code>//</code> and <code>Keyword:</code>!)</p>
</li>
<li>
<p>either <em>all</em> enumeration values (except the line with <code>NUM_XXX</code>) must have a keyword specification, or <em>none</em>  (the keyword spec is used to increment the enum counter)</p>
</li>
<li>
<p>you <strong>must not</strong> assign a value to the enumeration like <code>MY_ENUM = 15,</code> - the parser does not support this format. With proper scoping, you won&#8217;t need such assignments for parameter lists.</p>
</li>
</ul>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The parser isn&#8217;t a c++ parser and does not know about comments. If the strings mentioned above are found inside a comment, the parser will not know the difference. As a consequence, the following code will confuse the parser and generate wrong keyword categories:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
<span class="nl">public:</span>

    <span class="cm">/* Inside this
       class my stuff will work
       perfectly!
    */</span>

    <span class="k">enum</span> <span class="n">para_t</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="p">}</span>
<span class="p">...</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This will generate the keyword category <code>my::para_t</code> because <code>class my</code> is recognized as class scope. So, <strong>do not do this</strong>! Same applies to enum documentation.</p>
</div>
<div class="paragraph">
<p>Thankfully, documentation is to be placed above the class/enum declaration lines and should not interfere with the parsing.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>When using class forward declarations, always put only the class declaration on a single line without comments afterwards:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// forward declarations</span>
<span class="k">class</span> <span class="nc">OtherClass</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">OtherParentClass</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">YetAnotherClass</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The parser will detect forward declarations when the line is ended with a <code>;</code> character. Again, this should normally not be an issue, unless someone uses a forward declaration of a class <em>inside</em> a class scope.</p>
</div>
</div>
<div class="sect2">
<h3 id="_keyword_parameters">4.3. Keyword Parameters</h3>
<div class="paragraph">
<p>A keyword specification line has the following format:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>KW_ENUM_VALUE,  // Keyword:   Keyword-Name  [unit]  &lt;color&gt;  {default value} 'description'</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>Keyword-Name</code> can be actually a list of white-space separated keywords that are used to convert to the enumeration value: for example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>SP_HEATCONDCOEFF, // Keyword: HEATCONDCOEFF ALPHA [W/m2K] 'Heat conduction coefficient'</pre>
</div>
</div>
<div class="paragraph">
<p>Allows to convert strings <code>HEATCONDCOEFF</code> and <code>ALPHA</code> to enum value <code>SP_HEATCONDCOEFF</code>, but conversion from <code>SP_HEATCONDCOEFF</code> to string always yields the first keyword <code>HEATCONDCOEFF</code> in the list.</p>
</div>
<div class="paragraph">
<p>The remaining parameters <em>unit</em>, <em>color</em>, <em>default value</em> and <em>description</em> are <strong>optional</strong>. But if present, they must appear in the order shown above. This is just to avoid nesting problems and is strictly only required from the description, since this may potentially contain the characters <code>&lt;&gt;[]{}</code>.</p>
</div>
<div class="paragraph">
<p>The <em>default value</em> must be a floating point number in C locale format. Similarly as color and unit, this parameter is meaningful for user interfaces with somewhat generic parameter input handling.</p>
</div>
</div>
<div class="sect2">
<h3 id="xml_serialization_rules">4.4. XML Serialization</h3>
<div class="paragraph">
<p>In order for the CodeGenerator to work correct, we need a <span class="line-through">few</span> lots of conventions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>only one class per file</p>
</li>
<li>
<p>only member variables with <code>// XML:A</code> or <code>// XML:E</code> annotations are written/read (code generated for them)</p>
</li>
<li>
<p>all member variables must be prefixed <code>m_</code></p>
</li>
<li>
<p>only the types used in the following test class are currently supported. Complex types with own <code>readXML()</code> and <code>writeXML()</code> functions are always supported (see section <a href="#xml_complexTypes">Reading/writing custom complex types</a>)</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Example class with different types currently supported by code generator</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">SerializationTest</span> <span class="p">{</span>
<span class="nl">public:</span>

	<span class="n">NANDRAD_READWRITE</span>

	<span class="k">enum</span> <span class="n">test_t</span> <span class="p">{</span>
		<span class="n">t_x1</span><span class="p">,</span>												<span class="c1">// Keyword: X1</span>
		<span class="n">t_x2</span><span class="p">,</span>												<span class="c1">// Keyword: X2</span>
		<span class="n">NUM_test</span>
	<span class="p">};</span>

	<span class="k">enum</span> <span class="n">intPara_t</span> <span class="p">{</span>
		<span class="n">IP_i1</span><span class="p">,</span>												<span class="c1">// Keyword: I1</span>
		<span class="n">IP_i2</span><span class="p">,</span>												<span class="c1">// Keyword: I2</span>
		<span class="n">NUM_IP</span>
	<span class="p">};</span>

	<span class="k">enum</span> <span class="n">splinePara_t</span> <span class="p">{</span>
		<span class="n">SP_ParameterSet1</span><span class="p">,</span>									<span class="c1">// Keyword: ParameterSet1</span>
		<span class="n">SP_ParameterSet2</span><span class="p">,</span>									<span class="c1">// Keyword: ParameterSet2</span>
		<span class="n">NUM_SP</span>
	<span class="p">};</span>


	<span class="k">enum</span> <span class="n">ReferencedIDTypes</span> <span class="p">{</span>
		<span class="n">SomeStove</span><span class="p">,</span>											<span class="c1">// Keyword: SomeStove</span>
		<span class="n">SomeOven</span><span class="p">,</span>											<span class="c1">// Keyword: SomeOven</span>
		<span class="n">SomeHeater</span><span class="p">,</span>											<span class="c1">// Keyword: SomeHeater</span>
		<span class="n">SomeFurnace</span><span class="p">,</span>										<span class="c1">// Keyword: SomeFurnace</span>
		<span class="n">NUM_RefID</span>
	<span class="p">};</span>

	<span class="c1">// -&gt; id1="5"</span>
	<span class="kt">int</span>					<span class="n">m_id1</span>		<span class="o">=</span> <span class="mi">5</span><span class="p">;</span>					<span class="c1">// XML:A:required</span>
	<span class="c1">// -&gt; id2="10"</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">m_id2</span>		<span class="o">=</span> <span class="mi">10</span><span class="p">;</span>					<span class="c1">// XML:A</span>
	<span class="c1">// -&gt; flag1="0"</span>
	<span class="kt">bool</span>				<span class="n">m_flag1</span>		<span class="o">=</span> <span class="nb">false</span><span class="p">;</span>				<span class="c1">// XML:A</span>
	<span class="c1">// -&gt; val1="42.42"</span>
	<span class="kt">double</span>				<span class="n">m_val1</span>		<span class="o">=</span> <span class="mf">42.42</span><span class="p">;</span>				<span class="c1">// XML:A</span>
	<span class="c1">// -&gt; testBla="X1"</span>
	<span class="n">test_t</span>				<span class="n">m_testBla</span>	<span class="o">=</span> <span class="n">t_x1</span><span class="p">;</span>					<span class="c1">// XML:A</span>
	<span class="c1">// -&gt; str1="Blubb"</span>
	<span class="n">std</span><span class="o">::</span><span class="n">string</span>			<span class="n">m_str1</span>		<span class="o">=</span> <span class="s">"Blubb"</span><span class="p">;</span>				<span class="c1">// XML:A</span>
	<span class="c1">// -&gt; path1="/tmp"</span>
	<span class="n">IBK</span><span class="o">::</span><span class="n">Path</span>			<span class="n">m_path1</span>		<span class="o">=</span> <span class="n">IBK</span><span class="o">::</span><span class="n">Path</span><span class="p">(</span><span class="s">"/tmp"</span><span class="p">);</span>	<span class="c1">// XML:A</span>
	<span class="c1">// -&gt; u1="K"</span>
	<span class="n">IBK</span><span class="o">::</span><span class="n">Unit</span>			<span class="n">m_u1</span>		<span class="o">=</span> <span class="n">IBK</span><span class="o">::</span><span class="n">Unit</span><span class="p">(</span><span class="s">"K"</span><span class="p">);</span>		<span class="c1">// XML:A</span>

	<span class="c1">// -&gt; &lt;Id3&gt;10&lt;/Id3&gt;</span>
	<span class="kt">int</span>					<span class="n">m_id3</span>		<span class="o">=</span> <span class="mi">10</span><span class="p">;</span>					<span class="c1">// XML:E:required</span>
	<span class="c1">// -&gt; &lt;Id4&gt;12&lt;/Id4&gt;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">m_id4</span>		<span class="o">=</span> <span class="mi">12</span><span class="p">;</span>					<span class="c1">// XML:E</span>
	<span class="c1">// -&gt; &lt;Flag2&gt;1&lt;/Flag2&gt;</span>
	<span class="kt">bool</span>				<span class="n">m_flag2</span>		<span class="o">=</span> <span class="nb">true</span><span class="p">;</span>					<span class="c1">// XML:E</span>
	<span class="c1">// -&gt; &lt;Val2&gt;41.41&lt;/Val2&gt;</span>
	<span class="kt">double</span>				<span class="n">m_val2</span>		<span class="o">=</span> <span class="mf">41.41</span><span class="p">;</span>				<span class="c1">// XML:E</span>
	<span class="c1">// -&gt; &lt;TestBlo&gt;X2&lt;/TestBlo&gt;</span>
	<span class="n">test_t</span>				<span class="n">m_testBlo</span>	<span class="o">=</span> <span class="n">t_x2</span><span class="p">;</span>					<span class="c1">// XML:E</span>
	<span class="c1">// -&gt; &lt;Str2&gt;blabb&lt;/Str2&gt;</span>
	<span class="n">std</span><span class="o">::</span><span class="n">string</span>			<span class="n">m_str2</span>		<span class="o">=</span> <span class="s">"blabb"</span><span class="p">;</span>				<span class="c1">// XML:E</span>

	<span class="c1">// -&gt; &lt;Path2&gt;/var&lt;/Path2&gt;</span>
	<span class="n">IBK</span><span class="o">::</span><span class="n">Path</span>			<span class="n">m_path2</span>		<span class="o">=</span> <span class="n">IBK</span><span class="o">::</span><span class="n">Path</span><span class="p">(</span><span class="s">"/var"</span><span class="p">);</span>	<span class="c1">// XML:E</span>
	<span class="c1">// -&gt; undefined/empty - not written</span>
	<span class="n">IBK</span><span class="o">::</span><span class="n">Path</span>			<span class="n">m_path22</span><span class="p">;</span>							<span class="c1">// XML:E</span>

	<span class="c1">// -&gt; &lt;U2&gt;C&lt;/U2&gt;</span>
	<span class="n">IBK</span><span class="o">::</span><span class="n">Unit</span>			<span class="n">m_u2</span>		<span class="o">=</span> <span class="n">IBK</span><span class="o">::</span><span class="n">Unit</span><span class="p">(</span><span class="s">"C"</span><span class="p">);</span>		<span class="c1">// XML:E</span>
	<span class="c1">// -&gt; &lt;X5&gt;43.43&lt;/X5&gt;</span>
	<span class="kt">double</span>				<span class="n">m_x5</span>		<span class="o">=</span> <span class="mf">43.43</span><span class="p">;</span>				<span class="c1">// XML:E</span>

	<span class="c1">// -&gt; &lt;IBK:Flag name="F"&gt;true&lt;/IBK:Flag&gt;  -&gt; value of m_f.name is ignored</span>
	<span class="n">IBK</span><span class="o">::</span><span class="n">Flag</span>			<span class="n">m_f</span><span class="p">;</span>								<span class="c1">// XML:E</span>
	<span class="c1">// -&gt; undefined/empty - not written</span>
	<span class="n">IBK</span><span class="o">::</span><span class="n">Flag</span>			<span class="n">m_f2</span><span class="p">;</span>								<span class="c1">// XML:E</span>

	<span class="c1">// -&gt; &lt;Time1&gt;01.01.07 12:47:12&lt;/Time1&gt;</span>
	<span class="n">IBK</span><span class="o">::</span><span class="n">Time</span>			<span class="n">m_time1</span><span class="p">;</span>							<span class="c1">// XML:E</span>
	<span class="c1">// -&gt; undefined/empty - not written</span>
	<span class="n">IBK</span><span class="o">::</span><span class="n">Time</span>			<span class="n">m_time2</span><span class="p">;</span>							<span class="c1">// XML:E</span>

	<span class="c1">// -&gt; &lt;Table&gt;Col1:1,5,3;Col2:7,2,2;&lt;/Table&gt;</span>
	<span class="n">DataTable</span>			<span class="n">m_table</span><span class="p">;</span>							<span class="c1">// XML:E</span>
	<span class="c1">// -&gt; undefined/empty - not written</span>
	<span class="n">DataTable</span>			<span class="n">m_table2</span><span class="p">;</span>							<span class="c1">// XML:E</span>

	<span class="c1">// -&gt; 		&lt;DblVec&gt;0,12,24&lt;/DblVec&gt;</span>
	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span>		<span class="n">m_dblVec</span><span class="p">;</span>						<span class="c1">// XML:E</span>

	<span class="c1">// -&gt; &lt;Interfaces&gt;...&lt;/Interfaces&gt;</span>
	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Interface</span><span class="o">&gt;</span>	<span class="n">m_interfaces</span><span class="p">;</span>					<span class="c1">// XML:E</span>

	<span class="c1">// -&gt; &lt;InterfaceA&gt;....&lt;/InterfaceA&gt;  instead of &lt;Interface&gt;..&lt;/Interface&gt;</span>
	<span class="n">Interface</span>				<span class="n">m_interfaceA</span><span class="p">;</span>					<span class="c1">// XML:E:tag=InterfaceA</span>

	<span class="c1">// -&gt; &lt;IBK:Parameter name="SinglePara" unit="C"&gt;20&lt;/IBK:Parameter&gt;</span>
	<span class="n">IBK</span><span class="o">::</span><span class="n">Parameter</span>		<span class="n">m_singlePara</span><span class="p">;</span>						<span class="c1">// XML:E</span>

	<span class="c1">// -&gt; &lt;IBK:IntPara name="SingleIntegerPara"&gt;12&lt;/IBK:IntPara&gt;</span>
	<span class="n">IBK</span><span class="o">::</span><span class="n">IntPara</span>		<span class="n">m_singleIntegerPara</span> <span class="o">=</span> <span class="n">IBK</span><span class="o">::</span><span class="n">IntPara</span><span class="p">(</span><span class="s">"blubb"</span><span class="p">,</span><span class="mi">12</span><span class="p">);</span>	<span class="c1">// XML:E</span>

	<span class="c1">// -&gt; &lt;IBK:Parameter name="X1" unit="C"&gt;12&lt;/IBK:Parameter&gt;</span>
	<span class="n">IBK</span><span class="o">::</span><span class="n">Parameter</span>		<span class="n">m_para</span><span class="p">[</span><span class="n">NUM_test</span><span class="p">];</span>					<span class="c1">// XML:E</span>

	<span class="c1">// -&gt; &lt;IBK:IntPara name="I1"&gt;13&lt;/IBK:IntPara&gt;</span>
	<span class="n">IBK</span><span class="o">::</span><span class="n">IntPara</span>		<span class="n">m_intPara</span><span class="p">[</span><span class="n">NUM_IP</span><span class="p">];</span>					<span class="c1">// XML:E</span>

	<span class="c1">// -&gt; &lt;IBK:Flag name="X2"&gt;true&lt;/IBK:Flag&gt;</span>
	<span class="n">IBK</span><span class="o">::</span><span class="n">Flag</span>			<span class="n">m_flags</span><span class="p">[</span><span class="n">NUM_test</span><span class="p">];</span>					<span class="c1">// XML:E</span>

	<span class="n">IDType</span>				<span class="n">m_someStuffIDAsAttrib</span><span class="p">;</span>				<span class="c1">// XML:A</span>
	<span class="n">IDType</span>				<span class="n">m_someStuffIDAsElement</span><span class="p">;</span>				<span class="c1">// XML:E</span>

	<span class="c1">// -&gt; &lt;SomeStove&gt;231&lt;/SomeStove&gt; : Keywords must be unique!</span>
	<span class="n">IDType</span>				<span class="n">m_idReferences</span><span class="p">[</span><span class="n">NUM_RefID</span><span class="p">];</span>	        <span class="c1">// XML:E</span>

	<span class="c1">// -&gt; &lt;IBK:LinearSpline name="LinSpl"&gt;...&lt;/IBK:LinearSpline&gt;</span>
	<span class="n">IBK</span><span class="o">::</span><span class="n">LinearSpline</span>	<span class="n">m_linSpl</span><span class="p">;</span>							<span class="c1">// XML:E</span>

	<span class="c1">// -&gt; &lt;LinearSplineParameter name="SplineParameter"&gt;...&lt;/LinearSplineParameter&gt;</span>
	<span class="n">NANDRAD</span><span class="o">::</span><span class="n">LinearSplineParameter</span>	<span class="n">m_splineParameter</span><span class="p">;</span>		<span class="c1">// XML:E</span>
	<span class="c1">// -&gt; &lt;LinearSplineParameter name="AnotherSplineParameter"&gt;...&lt;/LinearSplineParameter&gt;</span>
	<span class="n">LinearSplineParameter</span>			<span class="n">m_anotherSplineParameter</span><span class="p">;</span>	<span class="c1">// XML:E</span>

	<span class="c1">// -&gt; &lt;LinearSplineParameter name="ParameterSet1"&gt;...&lt;/LinearSplineParameter&gt;</span>
	<span class="n">NANDRAD</span><span class="o">::</span><span class="n">LinearSplineParameter</span> <span class="n">m_splinePara</span><span class="p">[</span><span class="n">NUM_SP</span><span class="p">];</span>	<span class="c1">// XML:E</span>

	<span class="c1">// generic class with own readXML() and writeXML() function</span>
	<span class="c1">// -&gt; &lt;Schedule...&gt;...&lt;/Schedule&gt;</span>
	<span class="n">Schedule</span>			<span class="n">m_sched</span><span class="p">;</span>							<span class="c1">// XML:E</span>

	<span class="c1">// generic class with custom tag name</span>
	<span class="c1">// -&gt; &lt;OtherSchedule...&gt;...&lt;/OtherSchedule&gt;</span>
	<span class="n">Schedule</span>			<span class="n">m_sched2</span><span class="p">;</span>							<span class="c1">// XML:E:tag=OtherSchedule</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The following conventions are used when composing the XML content:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>parent XML-Element name is always the same as the class name, so in the example above the xml-tag is <code>SerializationTest</code>.</p>
</li>
<li>
<p>child tag names are composed of the capitalized variable name without <code>m_</code> prefix, so <code>m_testParameter</code> becomes <code>TestParameter</code></p>
</li>
<li>
<p>attribute names are composed of the variable name without <code>m_</code> prefix, so <code>m_flagFive</code> becomes attribute <code>flagFive</code></p>
</li>
<li>
<p>for vector quantities (for example <code>std::vector&lt;Interface&gt; m_interfaces</code>, the variable name is used to generate the list-type XML tag, here <code>Interfaces</code> (again just by capitalizing the variable name string). Inside the list the actual members are written, hereby calling <code>writeXML()</code> in the child elements (<code>Interface::writeXML()</code> in the example above)</p>
</li>
<li>
<p>static arrays are supported, but only with enumeration index where the enum is parametrized with keyword list and <code>NUM_xxx</code> enumeration value as last enum value. The xml-tags are named as the keywords for the corresponding enum type).</p>
</li>
<li>
<p>empty/undefined values are typically not written, for example when objects contain an empty <code>m_name</code> member variable</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The following XML-output is generated from the class declaration above (with some test data):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="xml"><span class="cp">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span>
<span class="nt">&lt;NandradProject&gt;</span>
	<span class="nt">&lt;SerializationTest</span> <span class="na">id1=</span><span class="s">"5"</span> <span class="na">id2=</span><span class="s">"10"</span> <span class="na">flag1=</span><span class="s">"0"</span> <span class="na">val1=</span><span class="s">"42.42"</span> <span class="na">testBla=</span><span class="s">"X1"</span> <span class="na">str1=</span><span class="s">"Blubb"</span> <span class="na">path1=</span><span class="s">"/tmp"</span> <span class="na">u1=</span><span class="s">"K"</span><span class="nt">&gt;</span>
		<span class="nt">&lt;Id3&gt;</span>10<span class="nt">&lt;/Id3&gt;</span>
		<span class="nt">&lt;Id4&gt;</span>12<span class="nt">&lt;/Id4&gt;</span>
		<span class="nt">&lt;Flag2&gt;</span>1<span class="nt">&lt;/Flag2&gt;</span>
		<span class="nt">&lt;Val2&gt;</span>41.41<span class="nt">&lt;/Val2&gt;</span>
		<span class="nt">&lt;TestBlo&gt;</span>X2<span class="nt">&lt;/TestBlo&gt;</span>
		<span class="nt">&lt;Str2&gt;</span>blabb<span class="nt">&lt;/Str2&gt;</span>
		<span class="nt">&lt;Path2&gt;</span>/var<span class="nt">&lt;/Path2&gt;</span>
		<span class="nt">&lt;U2&gt;</span>C<span class="nt">&lt;/U2&gt;</span>
		<span class="nt">&lt;X5&gt;</span>43.43<span class="nt">&lt;/X5&gt;</span>
		<span class="nt">&lt;IBK:Flag</span> <span class="na">name=</span><span class="s">"F"</span><span class="nt">&gt;</span>true<span class="nt">&lt;/IBK:Flag&gt;</span>
		<span class="nt">&lt;Time1&gt;</span>01.01.07 12:47:12<span class="nt">&lt;/Time1&gt;</span>
		<span class="nt">&lt;Table&gt;</span>Col1:1,5,3;Col2:7,2,2;<span class="nt">&lt;/Table&gt;</span>
		<span class="nt">&lt;DblVec&gt;</span>0,12,24<span class="nt">&lt;/DblVec&gt;</span>
		<span class="nt">&lt;Interfaces&gt;</span>
			<span class="nt">&lt;Interface</span> <span class="na">id=</span><span class="s">"1"</span> <span class="na">zoneId=</span><span class="s">"0"</span><span class="nt">&gt;</span>

			<span class="nt">&lt;/Interface&gt;</span>
		<span class="nt">&lt;/Interfaces&gt;</span>
		<span class="nt">&lt;IBK:Parameter</span> <span class="na">name=</span><span class="s">"SinglePara"</span> <span class="na">unit=</span><span class="s">"C"</span><span class="nt">&gt;</span>20<span class="nt">&lt;/IBK:Parameter&gt;</span>
		<span class="nt">&lt;IBK:IntPara</span> <span class="na">name=</span><span class="s">"SingleIntegerPara"</span><span class="nt">&gt;</span>12<span class="nt">&lt;/IBK:IntPara&gt;</span>
		<span class="nt">&lt;IBK:Parameter</span> <span class="na">name=</span><span class="s">"X1"</span> <span class="na">unit=</span><span class="s">"C"</span><span class="nt">&gt;</span>12<span class="nt">&lt;/IBK:Parameter&gt;</span>
		<span class="nt">&lt;IBK:IntPara</span> <span class="na">name=</span><span class="s">"I1"</span><span class="nt">&gt;</span>13<span class="nt">&lt;/IBK:IntPara&gt;</span>
		<span class="nt">&lt;IBK:IntPara</span> <span class="na">name=</span><span class="s">"I2"</span><span class="nt">&gt;</span>15<span class="nt">&lt;/IBK:IntPara&gt;</span>
		<span class="nt">&lt;IBK:Flag</span> <span class="na">name=</span><span class="s">"X2"</span><span class="nt">&gt;</span>true<span class="nt">&lt;/IBK:Flag&gt;</span>
		<span class="nt">&lt;IBK:LinearSpline</span> <span class="na">name=</span><span class="s">"LinSpl"</span><span class="nt">&gt;</span>
			<span class="nt">&lt;X</span> <span class="na">unit=</span><span class="s">"-"</span><span class="nt">&gt;</span>0 1 1.4 2 <span class="nt">&lt;/X&gt;</span>
			<span class="nt">&lt;Y</span> <span class="na">unit=</span><span class="s">"-"</span><span class="nt">&gt;</span>1 2 3.4 5 <span class="nt">&lt;/Y&gt;</span>
		<span class="nt">&lt;/IBK:LinearSpline&gt;</span>
		<span class="nt">&lt;LinearSplineParameter</span> <span class="na">name=</span><span class="s">"SplineParameter"</span><span class="nt">&gt;</span>
			<span class="nt">&lt;X</span> <span class="na">unit=</span><span class="s">"m"</span><span class="nt">&gt;</span>0 5 10 <span class="nt">&lt;/X&gt;</span>
			<span class="nt">&lt;Y</span> <span class="na">unit=</span><span class="s">"C"</span><span class="nt">&gt;</span>5 4 3 <span class="nt">&lt;/Y&gt;</span>
		<span class="nt">&lt;/LinearSplineParameter&gt;</span>
		<span class="nt">&lt;LinearSplineParameter</span> <span class="na">name=</span><span class="s">"AnotherSplineParameter"</span><span class="nt">&gt;</span>
			<span class="nt">&lt;X</span> <span class="na">unit=</span><span class="s">"m"</span><span class="nt">&gt;</span>0 5 10 <span class="nt">&lt;/X&gt;</span>
			<span class="nt">&lt;Y</span> <span class="na">unit=</span><span class="s">"C"</span><span class="nt">&gt;</span>5 4 3 <span class="nt">&lt;/Y&gt;</span>
		<span class="nt">&lt;/LinearSplineParameter&gt;</span>
		<span class="nt">&lt;LinearSplineParameter</span> <span class="na">name=</span><span class="s">"ParameterSet1"</span><span class="nt">&gt;</span>
			<span class="nt">&lt;X</span> <span class="na">unit=</span><span class="s">"m"</span><span class="nt">&gt;</span>0 5 10 <span class="nt">&lt;/X&gt;</span>
			<span class="nt">&lt;Y</span> <span class="na">unit=</span><span class="s">"C"</span><span class="nt">&gt;</span>5 4 3 <span class="nt">&lt;/Y&gt;</span>
		<span class="nt">&lt;/LinearSplineParameter&gt;</span>
		<span class="nt">&lt;Schedule</span> <span class="na">type=</span><span class="s">"Friday"</span><span class="nt">&gt;</span>
			<span class="nt">&lt;StartDayOfTheYear&gt;</span>0<span class="nt">&lt;/StartDayOfTheYear&gt;</span>
			<span class="nt">&lt;EndDayOfTheYear&gt;</span>0<span class="nt">&lt;/EndDayOfTheYear&gt;</span>
			<span class="nt">&lt;DailyCycles&gt;</span>
				<span class="nt">&lt;DailyCycle</span> <span class="nt">/&gt;</span>
			<span class="nt">&lt;/DailyCycles&gt;</span>
		<span class="nt">&lt;/Schedule&gt;</span>
		<span class="nt">&lt;OtherSchedule</span> <span class="na">type=</span><span class="s">"Friday"</span><span class="nt">&gt;</span>
			<span class="nt">&lt;StartDayOfTheYear&gt;</span>0<span class="nt">&lt;/StartDayOfTheYear&gt;</span>
			<span class="nt">&lt;EndDayOfTheYear&gt;</span>0<span class="nt">&lt;/EndDayOfTheYear&gt;</span>
			<span class="nt">&lt;DailyCycles&gt;</span>
				<span class="nt">&lt;DailyCycle</span> <span class="nt">/&gt;</span>
			<span class="nt">&lt;/DailyCycles&gt;</span>
		<span class="nt">&lt;/OtherSchedule&gt;</span>
	<span class="nt">&lt;/SerializationTest&gt;</span>
<span class="nt">&lt;/NandradProject&gt;</span></code></pre>
</div>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
<div class="paragraph">
<p>When writing custom types like <code>Schedule</code> in the example above, you <strong>must only have one object</strong> declared as member variable, since the xml-tag is generated based on the variable type name. This is due to the fact, that the code generator currently just calls <code>writeXML()</code> inside such complex types and these classes (currently) set the child xml tag name to the class name. In the example above, the class name is <code>Schedule</code> and hence the xml-tag is named <code>Schedule</code> and not <code>Sched</code> as it would be according to the standard naming rules.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>For types <code>IBK::Parameter</code>, <code>IBK::IntPara</code>, <code>IBK::LinearSpline</code> and <code>IBK::Flag</code> the name must be set exactly to the name of the generated xml-tag name. So, a parameter with member variable <code>m_transferCoefficient</code> must be given the name <code>TransferCoefficient</code>. In case of static arrays, where the enumeration value determines keyword and thus xml-tag, the name is ignored.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The code generator creates additional code to prevent writing of undefined data:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>IBK::Parameter</code>, <code>IBK::IntPara</code> and <code>IBK::Flag</code> with empty name are not written</p>
</li>
<li>
<p>enumeration values where the value matches the corresponding <code>NUM_xxx</code> value are not written</p>
</li>
<li>
<p><code>IBK::Time</code> with invalid time/date are not written</p>
</li>
<li>
<p>empty strings/paths are not written</p>
</li>
<li>
<p>undefined units (id=0) are not written</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_idtype_variables">4.4.1. IDType variables</h4>
<div class="paragraph">
<p>The variable type <code>IDType</code> is actually a typedef for <code>unsigned int</code> and should be used only for ID references. The typdef is declared in <code>NANDRAD_CodeGenMacros.h</code>. When the IDType is used for scalar variables, it is serialized exactly as <code>unsigned int</code>. However, it can also be used in a C-array with enumeration values, like in the following example:</p>
</div>
<div class="listingblock">
<div class="title">IDType array variables</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">SerializationTest</span> <span class="p">{</span>
<span class="nl">public:</span>

	<span class="n">NANDRAD_READWRITE</span>

	<span class="k">enum</span> <span class="n">ReferencedIDTypes</span> <span class="p">{</span>
		<span class="n">SomeStove</span><span class="p">,</span>											<span class="c1">// Keyword: SomeStove</span>
		<span class="n">SomeOven</span><span class="p">,</span>											<span class="c1">// Keyword: SomeOven</span>
		<span class="n">SomeHeater</span><span class="p">,</span>											<span class="c1">// Keyword: SomeHeater</span>
		<span class="n">SomeFurnace</span><span class="p">,</span>										<span class="c1">// Keyword: SomeFurnace</span>
		<span class="n">NUM_RefID</span>
	<span class="p">};</span>

	<span class="c1">// -&gt; &lt;SomeStove&gt;231&lt;/SomeStove&gt; : Keywords must be unique!</span>
	<span class="n">IDType</span> <span class="n">m_idReferences</span><span class="p">[</span><span class="n">NUM_RefID</span><span class="p">];</span>	                    <span class="c1">// XML:E</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The array size <strong>must</strong> be defined by an enumeration counter value that matches the size of the enumeration list.
Also, the corresponding enumeration <strong>must</strong> have keywords for the keyword list.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Whether <code>IDType</code> variables are scalar variables or within a c-array, they are only written to XML if their value is not equal to <code>NANDRAD::INVALID_ID</code>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="xml_complexTypes">4.4.2. Reading/writing custom complex types</h4>
<div class="paragraph">
<p>Any data type not listed in the example above and with <code>// XML:E</code> annotation is treated by the code generator as a complex type with own functions <code>readXML()</code> and <code>writeXML()</code> according to the <code>NANDRAD_READWRITE</code> macro. The code generator with create code to simply call these functions when writing such code.</p>
</div>
<div class="paragraph">
<p>When reading an XML-file, the tag is compared with the typename of the member variable (<code>Schedule</code> in the example above for member variable <code>m_sched</code>) and if matched, an object of said type is created and the <code>readXML()</code> function is called for this child tag. Then, the variable is <em>assigned</em> to the member variable. Hence, the complex type also requires an assignment operator. This is usually automatically generated, but for classes with pointers or special resource management, you may need to provide this assignment operator in addition to the <code>readXML() and `writeXML()</code> functions.</p>
</div>
</div>
<div class="sect3">
<h4 id="_readingwriting_custom_complex_types_with_user_defined_tag_names">4.4.3. Reading/writing custom complex types with user-defined tag names</h4>
<div class="paragraph">
<p>Normally, the tag names for complex types are generated based on the complex type&#8217;s class name. For example:</p>
</div>
<div class="listingblock">
<div class="title">Example for complex data member with automatic tag name generation</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">Interface</span> <span class="n">m_iface</span><span class="p">;</span>  <span class="c1">// XML:E</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>will generate an XML-file with:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="xml"><span class="nt">&lt;Interface</span> <span class="na">id=</span><span class="s">"1"</span> <span class="na">zoneId=</span><span class="s">"0"</span><span class="nt">&gt;</span>
	<span class="c">&lt;!--Interface to outside--&gt;</span>
<span class="nt">&lt;/Interface&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If you would like to use a different tag name, for example to distinguish between different variables of the same complex type, you can use the <code>XML:E:tag=&lt;custom tag name&gt;</code> syntax.</p>
</div>
<div class="listingblock">
<div class="title">Example for complex data member with custom tag name</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">Interface</span> <span class="n">m_iface</span><span class="p">;</span>  <span class="c1">// XML:E:tag=MyFancyInterface</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>will generate an XML-file with:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="xml"><span class="nt">&lt;MyFancyInterface</span> <span class="na">id=</span><span class="s">"1"</span> <span class="na">zoneId=</span><span class="s">"0"</span><span class="nt">&gt;</span>
	<span class="c">&lt;!--Interface to outside--&gt;</span>
<span class="nt">&lt;/MyFancyInterface&gt;</span></code></pre>
</div>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
<div class="paragraph">
<p>This feature works <strong>only</strong> with element tags and custom complex data types.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_handling_of_uninitialized_ids_nandradinvalid_id">4.4.4. Handling of uninitialized IDs (<code>= NANDRAD::INVALID_ID</code>)</h4>
<div class="paragraph">
<p>The code generator automatically inserts code that compares unsigned int parameters with the constant <code>NANDRAD::INVALID_ID</code>. If the variable holds this default value, the variable will not be written.</p>
</div>
<div class="paragraph">
<p>This avoids writing invalid IDs for optional references.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Unsigned int variables with value <code>NANDRAD::INVALID_ID</code> are expected to identify that <em>an optional parameter is omitted</em> or not provided. Hence, the respective variable should always be initialized with <code>NANDRAD::INVALID_ID</code> in the class header/constructor. When accessing the variable before or after reading the project file, it is possible to check by comparing with the constant if the variable is given or not.</p>
</div>
<div class="paragraph">
<p>Care has to be taken when an existing optional data member is deactivated by setting its id to <code>NANDRAD::INVALID_ID</code>. All other members should equally be cleared, so that a data member (with potentially mandatory ID) is not being written to file, whereby some regular data members appear in the XML tag, but not the ID. This will work during writing of the project, but <strong>fail</strong>, when the project is being read in again.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_unsupported_data_member_types">4.4.5. Unsupported data member types</h4>
<div class="paragraph">
<p>For any kind of special data types, like <code>std::map&lt;std::string, std::vector&lt;double&gt; &gt;</code> you cannot use the code generator to create read/write code for. When you add a read/write annotation to such variables, the code generator will complain about unsupported types and may generate not compiling code.</p>
</div>
<div class="paragraph">
<p>In such cases you have two options:</p>
</div>
<div class="olist loweralpha">
<ol class="loweralpha">
<li>
<p>create your own <code>readXML()</code> and <code>writeXML()</code> functions (possibly by copy&amp;pasting other generated functions from <code>ncg_*</code> files and adjusting the code to your needs). For other member variables whose types are supported by the code generator, you may still use the code generator, but you must use the <code>NANDRAD_READWRITE_PRIVATE</code> macro (see example in section <a href="#xml_custom_readwrite">Custom read/write functionality</a>).</p>
</li>
<li>
<p>change the type to something different, possibly creating another class with standardized behavior. So, for example, you could store <code>std::map&lt;std::string, std::vector&lt;double&gt; &gt;</code>  data in <code>std::vector&lt;NamedDblVector&gt;</code> where <code>NamedDblVector</code> contains a <code>std::string</code> and <code>std::vector&lt;double&gt;</code> members, both of which are fully supported by the code generator. You may need to code the check for duplicate names yourself.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_xml_comments">4.4.6. XML Comments</h4>
<div class="paragraph">
<p>Sometimes, it is nice to add comments about certain data members in the file. These are not xml tags, but merely xml comments and as such have no meaning for the project (only for humans reading the file in the text editor).</p>
</div>
<div class="paragraph">
<p>Since comments may add quite a bit of text to project files and enlarge these without adding actual data, care should be taken to only add comments when necessary/helpful for manually checking the content of files.</p>
</div>
<div class="paragraph">
<p>Currently, only one string comment is allowed per class, and it will be written right after the opening tag of the class XML tag. To add a comment, you must create a <code>std::string</code> variable with a <code>XML:C</code> annotation.</p>
</div>
<div class="paragraph">
<p>For example:</p>
</div>
<div class="listingblock">
<div class="title">Using a comment annotation on a string variable</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">Interface</span> <span class="p">{</span>
<span class="nl">public:</span>

    <span class="p">...</span>

	<span class="cm">/*! Comment, indicating the zone this interface links to. */</span>
	<span class="n">std</span><span class="o">::</span><span class="n">string</span>									<span class="n">m_comment</span><span class="p">;</span>				<span class="c1">// XML:C</span>

	<span class="p">...</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Suppose the string <code>m_comment</code> contains the text <em>Interface to 'TF05.1</em>, then the generated XML content will look like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="xml"><span class="nt">&lt;Interface</span> <span class="na">id=</span><span class="s">"12"</span> <span class="na">zoneId=</span><span class="s">"1"</span><span class="nt">&gt;</span>
	<span class="c">&lt;!--Interface to 'TF05.1'--&gt;</span>
	<span class="nt">&lt;InterfaceHeatConduction</span> <span class="na">modelType=</span><span class="s">"Constant"</span><span class="nt">&gt;</span>
    ...
<span class="nt">&lt;/Interface&gt;</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>You can have multi-line comments, by adding <code>\n</code> in the string, but the indentation in the XML file will be missing in subsequent lines. Generally, don&#8217;t do this.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>You cannot combine <code>XML:C</code> with any other xml element option.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_serialization_of_inherited_data_members">4.4.7. Serialization of inherited data members</h4>
<div class="paragraph">
<p>Sometimes a base class holds data members that should be serialized in derived classes. Rather than manually implementing <code>readXML()</code> and <code>writeXML()</code> functions, you can simply copy the variable declaration into the derived class, add the <code>XML:...</code> serialization suffix and then prefix the entire line with <code>//:inherited</code> like in the following example.</p>
</div>
<div class="listingblock">
<div class="title">Serialization of inherited data members</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">Parent</span> <span class="p">{</span>
<span class="nl">public:</span>

    <span class="kt">int</span> <span class="n">m_value</span><span class="p">;</span>
<span class="p">};</span>


<span class="k">class</span> <span class="nc">Child</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Parent</span> <span class="p">{</span>

    <span class="c1">// the following line tells the code generator to generate the serialization code</span>
    <span class="c1">// for variable m_value. The C++ compiler ignores this line.</span>

    <span class="c1">//:inherited int m_value; // XML:E</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Basically, the code generator looks for the token <code>//:inherited</code>, removes it from the line and then handles the line just as a regular variable declaration with serialization tag.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ignoring_additional_class_declarations_in_same_header_file">4.5. Ignoring additional class declarations in same header file</h3>
<div class="paragraph">
<p>Use a code comment <code>NO KEYWORDS</code> behind the class to ignore during keyword/serialization parsing to prevent the code generator from analysing this data structure.</p>
</div>
<div class="listingblock">
<div class="title">Ignoring embedded class declaration</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">Bla</span> <span class="p">{</span>
<span class="nl">public:</span>

    <span class="p">....</span>

    <span class="c1">// ignore embedded class declaration when</span>
    <span class="c1">// generating keyword list/serialization code</span>
    <span class="k">class</span> <span class="nc">Blubb</span> <span class="p">{</span> <span class="c1">// NO KEYWORDS</span>
    <span class="p">};</span>

<span class="p">}</span></code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 1.1 (28.12.2022)<br>
Last updated 2022-12-28 06:53:32 +0100
</div>
</div>
<style>
pre.rouge table td { padding: 5px; }
pre.rouge table pre { margin: 0; }
pre.rouge .cm {
  color: #999988;
  font-style: italic;
}
pre.rouge .cp {
  color: #999999;
  font-weight: bold;
}
pre.rouge .c1 {
  color: #999988;
  font-style: italic;
}
pre.rouge .cs {
  color: #999999;
  font-weight: bold;
  font-style: italic;
}
pre.rouge .c, pre.rouge .ch, pre.rouge .cd, pre.rouge .cpf {
  color: #999988;
  font-style: italic;
}
pre.rouge .err {
  color: #a61717;
  background-color: #e3d2d2;
}
pre.rouge .gd {
  color: #000000;
  background-color: #ffdddd;
}
pre.rouge .ge {
  color: #000000;
  font-style: italic;
}
pre.rouge .gr {
  color: #aa0000;
}
pre.rouge .gh {
  color: #999999;
}
pre.rouge .gi {
  color: #000000;
  background-color: #ddffdd;
}
pre.rouge .go {
  color: #888888;
}
pre.rouge .gp {
  color: #555555;
}
pre.rouge .gs {
  font-weight: bold;
}
pre.rouge .gu {
  color: #aaaaaa;
}
pre.rouge .gt {
  color: #aa0000;
}
pre.rouge .kc {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kd {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kn {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kp {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kr {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kt {
  color: #445588;
  font-weight: bold;
}
pre.rouge .k, pre.rouge .kv {
  color: #000000;
  font-weight: bold;
}
pre.rouge .mf {
  color: #009999;
}
pre.rouge .mh {
  color: #009999;
}
pre.rouge .il {
  color: #009999;
}
pre.rouge .mi {
  color: #009999;
}
pre.rouge .mo {
  color: #009999;
}
pre.rouge .m, pre.rouge .mb, pre.rouge .mx {
  color: #009999;
}
pre.rouge .sa {
  color: #000000;
  font-weight: bold;
}
pre.rouge .sb {
  color: #d14;
}
pre.rouge .sc {
  color: #d14;
}
pre.rouge .sd {
  color: #d14;
}
pre.rouge .s2 {
  color: #d14;
}
pre.rouge .se {
  color: #d14;
}
pre.rouge .sh {
  color: #d14;
}
pre.rouge .si {
  color: #d14;
}
pre.rouge .sx {
  color: #d14;
}
pre.rouge .sr {
  color: #009926;
}
pre.rouge .s1 {
  color: #d14;
}
pre.rouge .ss {
  color: #990073;
}
pre.rouge .s, pre.rouge .dl {
  color: #d14;
}
pre.rouge .na {
  color: #008080;
}
pre.rouge .bp {
  color: #999999;
}
pre.rouge .nb {
  color: #0086B3;
}
pre.rouge .nc {
  color: #445588;
  font-weight: bold;
}
pre.rouge .no {
  color: #008080;
}
pre.rouge .nd {
  color: #3c5d5d;
  font-weight: bold;
}
pre.rouge .ni {
  color: #800080;
}
pre.rouge .ne {
  color: #990000;
  font-weight: bold;
}
pre.rouge .nf, pre.rouge .fm {
  color: #990000;
  font-weight: bold;
}
pre.rouge .nl {
  color: #990000;
  font-weight: bold;
}
pre.rouge .nn {
  color: #555555;
}
pre.rouge .nt {
  color: #000080;
}
pre.rouge .vc {
  color: #008080;
}
pre.rouge .vg {
  color: #008080;
}
pre.rouge .vi {
  color: #008080;
}
pre.rouge .nv, pre.rouge .vm {
  color: #008080;
}
pre.rouge .ow {
  color: #000000;
  font-weight: bold;
}
pre.rouge .o {
  color: #000000;
  font-weight: bold;
}
pre.rouge .w {
  color: #bbbbbb;
}
pre.rouge {
  background-color: #f8f8f8;
}
</style>
</body>
</html>