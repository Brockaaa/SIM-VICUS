<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.16">
<meta name="author" content="Andreas Nicolai">
<title>SIM-VICUS Plugin Entwicklung</title>
<style>
/* Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */

@import url(../css/asciidoctor.css); /* Default asciidoc style framework - important */

/* roboto-condensed-regular - latin */
@font-face {
  font-family: 'Roboto Condensed';
  font-style: normal;
  font-weight: 400;
  src: url('../fonts/roboto-condensed-v25-latin-regular.eot'); /* IE9 Compat Modes */
  src: local(''),
       url('../fonts/roboto-condensed-v25-latin-regular.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */
       url('../fonts/roboto-condensed-v25-latin-regular.woff2') format('woff2'), /* Super Modern Browsers */
       url('../fonts/roboto-condensed-v25-latin-regular.woff') format('woff'), /* Modern Browsers */
       url('../fonts/roboto-condensed-v25-latin-regular.ttf') format('truetype'), /* Safari, Android, iOS */
       url('../fonts/roboto-condensed-v25-latin-regular.svg#RobotoCondensed') format('svg'); /* Legacy iOS */
}
/* roboto-condensed-italic - latin */
@font-face {
  font-family: 'Roboto Condensed';
  font-style: italic;
  font-weight: 400;
  src: url('../fonts/roboto-condensed-v25-latin-italic.eot'); /* IE9 Compat Modes */
  src: local(''),
       url('../fonts/roboto-condensed-v25-latin-italic.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */
       url('../fonts/roboto-condensed-v25-latin-italic.woff2') format('woff2'), /* Super Modern Browsers */
       url('../fonts/roboto-condensed-v25-latin-italic.woff') format('woff'), /* Modern Browsers */
       url('../fonts/roboto-condensed-v25-latin-italic.ttf') format('truetype'), /* Safari, Android, iOS */
       url('../fonts/roboto-condensed-v25-latin-italic.svg#RobotoCondensed') format('svg'); /* Legacy iOS */
}
/* roboto-condensed-700 - latin */
@font-face {
  font-family: 'Roboto Condensed';
  font-style: normal;
  font-weight: 700;
  src: url('../fonts/roboto-condensed-v25-latin-700.eot'); /* IE9 Compat Modes */
  src: local(''),
       url('../fonts/roboto-condensed-v25-latin-700.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */
       url('../fonts/roboto-condensed-v25-latin-700.woff2') format('woff2'), /* Super Modern Browsers */
       url('../fonts/roboto-condensed-v25-latin-700.woff') format('woff'), /* Modern Browsers */
       url('../fonts/roboto-condensed-v25-latin-700.ttf') format('truetype'), /* Safari, Android, iOS */
       url('../fonts/roboto-condensed-v25-latin-700.svg#RobotoCondensed') format('svg'); /* Legacy iOS */
}
/* roboto-condensed-700italic - latin */
@font-face {
  font-family: 'Roboto Condensed';
  font-style: italic;
  font-weight: 700;
  src: url('../fonts/roboto-condensed-v25-latin-700italic.eot'); /* IE9 Compat Modes */
  src: local(''),
       url('../fonts/roboto-condensed-v25-latin-700italic.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */
       url('../fonts/roboto-condensed-v25-latin-700italic.woff2') format('woff2'), /* Super Modern Browsers */
       url('../fonts/roboto-condensed-v25-latin-700italic.woff') format('woff'), /* Modern Browsers */
       url('../fonts/roboto-condensed-v25-latin-700italic.ttf') format('truetype'), /* Safari, Android, iOS */
       url('../fonts/roboto-condensed-v25-latin-700italic.svg#RobotoCondensed') format('svg'); /* Legacy iOS */
}

/* CUSTOMISATIONS */
/* Change the values in root for quick customisation. If you want even more fine grain... venture further. */

:root{
--maincolor:#FFFFFF;
--primarycolor:#a90e22;
--secondarycolor:#9f1d0b;
--tertiarycolor: #ededed;
--sidebarbackground:#CCC;
--linkcolor:#b71c1c;
--linkcoloralternate:#f44336;
--white:#FFFFFF;
--black:#000000;
}

/* Text styles */
body{font-family: "Roboto Condensed",sans-serif;}

h1,h2{color:var(--primarycolor) !important;font-family:"Roboto Condensed",sans-serif;}
h3,h4,h5,h6{color:var(--secondarycolor);font-family: "Roboto Condensed",sans-serif; }
.title{color:(--primarycolor) !important;font-family:"Roboto Condensed",sans-serif;font-style: normal; font-weight: normal;}
p{font-family: "Roboto Condensed",sans-serif ! important}
#toc.toc2 a{font-family:"Roboto Condensed",sans-serif;}
/*#toc.toc2 a:link{color:(--linkcolor) !important}
a:visited {color: #ffdbad;}
a.bare:visited {color: #204f83;}
a:hover {color: #317ed4;}
#toc.toc2 a:hover {color: #f1b464;}*/
/* code{background-color: var(--secondarycolor) !important;color:var(--white)} */
code,kbd,pre,samp{font-family:"Consolas","Droid Sans Mono","DejaVu Sans Mono",monospace;monospace;font-size:1em}

/* Table styles */
th{background-color: var(--tertiarycolor);color:var(--black) !important;}

#toctitle{color:var(--primarycolor);font-family: "Roboto Condensed",sans-serif;font-size: 1.6875em;}
#toc.toc2{background-color:#f4f8fd;}
/*#toc.toc2{background-color:#2C001E;color:white;}
#toc.toc2.a{color:white;}
*/

/* Responsiveness fixes */
video {
  max-width: 100%;
}

@media all and (max-width: 600px) {
table {
  width: 55vw!important;
  font-size: 3vw;
}

</style>
<link rel="stylesheet" href="../css/font-awesome.css">
<style>
pre.rouge table td { padding: 5px; }
pre.rouge table pre { margin: 0; }
pre.rouge .cm {
  color: #999988;
  font-style: italic;
}
pre.rouge .cp {
  color: #999999;
  font-weight: bold;
}
pre.rouge .c1 {
  color: #999988;
  font-style: italic;
}
pre.rouge .cs {
  color: #999999;
  font-weight: bold;
  font-style: italic;
}
pre.rouge .c, pre.rouge .ch, pre.rouge .cd, pre.rouge .cpf {
  color: #999988;
  font-style: italic;
}
pre.rouge .err {
  color: #a61717;
  background-color: #e3d2d2;
}
pre.rouge .gd {
  color: #000000;
  background-color: #ffdddd;
}
pre.rouge .ge {
  color: #000000;
  font-style: italic;
}
pre.rouge .gr {
  color: #aa0000;
}
pre.rouge .gh {
  color: #999999;
}
pre.rouge .gi {
  color: #000000;
  background-color: #ddffdd;
}
pre.rouge .go {
  color: #888888;
}
pre.rouge .gp {
  color: #555555;
}
pre.rouge .gs {
  font-weight: bold;
}
pre.rouge .gu {
  color: #aaaaaa;
}
pre.rouge .gt {
  color: #aa0000;
}
pre.rouge .kc {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kd {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kn {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kp {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kr {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kt {
  color: #445588;
  font-weight: bold;
}
pre.rouge .k, pre.rouge .kv {
  color: #000000;
  font-weight: bold;
}
pre.rouge .mf {
  color: #009999;
}
pre.rouge .mh {
  color: #009999;
}
pre.rouge .il {
  color: #009999;
}
pre.rouge .mi {
  color: #009999;
}
pre.rouge .mo {
  color: #009999;
}
pre.rouge .m, pre.rouge .mb, pre.rouge .mx {
  color: #009999;
}
pre.rouge .sa {
  color: #000000;
  font-weight: bold;
}
pre.rouge .sb {
  color: #d14;
}
pre.rouge .sc {
  color: #d14;
}
pre.rouge .sd {
  color: #d14;
}
pre.rouge .s2 {
  color: #d14;
}
pre.rouge .se {
  color: #d14;
}
pre.rouge .sh {
  color: #d14;
}
pre.rouge .si {
  color: #d14;
}
pre.rouge .sx {
  color: #d14;
}
pre.rouge .sr {
  color: #009926;
}
pre.rouge .s1 {
  color: #d14;
}
pre.rouge .ss {
  color: #990073;
}
pre.rouge .s, pre.rouge .dl {
  color: #d14;
}
pre.rouge .na {
  color: #008080;
}
pre.rouge .bp {
  color: #999999;
}
pre.rouge .nb {
  color: #0086B3;
}
pre.rouge .nc {
  color: #445588;
  font-weight: bold;
}
pre.rouge .no {
  color: #008080;
}
pre.rouge .nd {
  color: #3c5d5d;
  font-weight: bold;
}
pre.rouge .ni {
  color: #800080;
}
pre.rouge .ne {
  color: #990000;
  font-weight: bold;
}
pre.rouge .nf, pre.rouge .fm {
  color: #990000;
  font-weight: bold;
}
pre.rouge .nl {
  color: #990000;
  font-weight: bold;
}
pre.rouge .nn {
  color: #555555;
}
pre.rouge .nt {
  color: #000080;
}
pre.rouge .vc {
  color: #008080;
}
pre.rouge .vg {
  color: #008080;
}
pre.rouge .vi {
  color: #008080;
}
pre.rouge .nv, pre.rouge .vm {
  color: #008080;
}
pre.rouge .ow {
  color: #000000;
  font-weight: bold;
}
pre.rouge .o {
  color: #000000;
  font-weight: bold;
}
pre.rouge .w {
  color: #bbbbbb;
}
pre.rouge {
  background-color: #f8f8f8;
}
</style>
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>SIM-VICUS Plugin Entwicklung</h1>
<div class="details">
<span id="author" class="author">Andreas Nicolai</span><br>
<span id="email" class="email"><a href="https://github.com/ghorwin" class="bare">https://github.com/ghorwin</a></span><br>
<span id="revnumber">version 1.0 (31.12.2022)</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Inhaltsverzeichnis</div>
<ul class="sectlevel1">
<li><a href="#_hintergrund_informationen">1. Hintergrund-Informationen</a>
<ul class="sectlevel2">
<li><a href="#_dynamische_bibliotheken_und_binärkompatibilität">1.1. Dynamische Bibliotheken und Binärkompatibilität</a></li>
<li><a href="#_quelltextunterschiede_und_versionierung">1.2. Quelltextunterschiede und Versionierung</a>
<ul class="sectlevel3">
<li><a href="#_fall_1_gemeinsam_genutzte_datenstruktur_im_hauptprogramm_ändert_sich">1.2.1. Fall 1: Gemeinsam genutzte Datenstruktur im Hauptprogramm ändert sich</a></li>
<li><a href="#_fall_2_plugin_schnittstelle_ändert_sich">1.2.2. Fall 2: Plugin-Schnittstelle ändert sich</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_hintergrund_informationen">1. Hintergrund-Informationen</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_dynamische_bibliotheken_und_binärkompatibilität">1.1. Dynamische Bibliotheken und Binärkompatibilität</h3>
<div class="paragraph">
<p>Plugins sind letztlich dynamisch geladene Bibliotheken, bzw. <em>shared library</em> oder <em>dynamically linked library (DLL)</em>. Zum Verständnis der Versionierungsanforderungen unten hilft vielleicht ein kurzer Einblick in die interne Funktionsweise von C/C++.</p>
</div>
<div class="paragraph">
<p>In C/C++ werden Variablen über Speicheradressen verwaltet. Über die Adresse im Speicher und den Typ weiß der Compiler, wie der rohe Speicherinhalt zu interpretieren ist.
Bei Objekten (<em>struct</em> oder <em>class</em>) wird die Adresse auf den Beginn des Objekts gespeichert. Bei Membervariablen weiß der Compiler dann durch deren Typen und <em>offset</em> (Abstand von der Startadresse des Objekts), wo im darauffolgenden Speicher deren Daten liegen.</p>
</div>
<div class="paragraph">
<p>Der <em>offset</em> einer Membervariablen ist aber nicht nur von der Größe der jeweiligen Datentypen abhängig. Zusätzlich werden die einzelnen Variablen noch am Speicherraster ausgerichtet, durch ein sogenanntes <em>padding</em> (siehe auch <a href="https://en.wikipedia.org/wiki/Data_structure_alignment" class="bare">https://en.wikipedia.org/wiki/Data_structure_alignment</a> ).</p>
</div>
<div class="paragraph">
<p>Das Padding ist compiler- und plattformabhängig, da das binäre Speicherlayout bei C/C++ nicht standardisiert ist (was auch gut ist, da so hardwarespezifisch optimaler Code generiert werden kann). Man kann das beispielsweise austesten, indem man das Testprogramm <a href="#ex_struct">Beispiel 1</a> mit verschiedenen Compilern und Betriebssystemen ausführt.</p>
</div>
<div id="ex_struct" class="exampleblock">
<div class="title">Beispiel 1. Beispiel für die unterschiedliche Größe von Strukturen durch Padding in Abhängigkeit von Typ und Reihenfolge der Membervariablen. <code>sizeof</code> liefert den Speicherbedarf für eine Variable, <code>offsetof</code> liefert die Anzahl der Bytes zwischen Aresse des Objekts und Adresse der Membervariablen.</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">struct</span> <span class="nc">A</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">c</span><span class="p">;</span> <span class="c1">// 1 Byte</span>
    <span class="kt">char</span> <span class="n">d</span><span class="p">;</span> <span class="c1">// 1 Byte</span>
            <span class="c1">// 2 Byte Padding</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>  <span class="c1">// 4 Byte</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">B</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">c</span><span class="p">;</span> <span class="c1">// 1 Byte</span>
            <span class="c1">// 3 Byte Padding</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>  <span class="c1">// 4 Byte</span>
    <span class="kt">char</span> <span class="n">d</span><span class="p">;</span> <span class="c1">// 1 Byte</span>
            <span class="c1">// 3 Byte Padding</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">A</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">B</span> <span class="n">b</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Size of A: "</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"  Offset of A.d: "</span> <span class="o">&lt;&lt;</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">d</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"  Offset of A.i: "</span> <span class="o">&lt;&lt;</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Size of B: "</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">B</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"  Offset of B.i: "</span> <span class="o">&lt;&lt;</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"  Offset of B.d: "</span> <span class="o">&lt;&lt;</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="n">d</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="c1">// Ausgabe:</span>
<span class="c1">// Size of A: 8</span>
<span class="c1">//   Offset of A.d: 1</span>
<span class="c1">//   Offset of A.i: 4</span>
<span class="c1">// Size of B: 12</span>
<span class="c1">//   Offset of B.i: 4</span>
<span class="c1">//   Offset of B.d: 8</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Am Beispiel wird deutlich, dass die Reihenfolge der Membervariablen in einem struct oder einer Klasse Auswirkungen auf die Speicheranordnung hat. Bei unterschiedlichen Compilern/Plattformen kann das auch individuell unterschiedlich gemacht werden, sodass aus dem gleichen C/C++-Code von unterschiedlichen Compilern generierter Binärcode eventuell unterschiedlich im Speicher abgelegt wird.  Glücklicherweise machen die meisten Compiler heutzutage auf x86 bzw. x64-Systemen das Gleiche, man kann sich jedoch leider <em>nicht darauf verlassen</em>.</p>
</div>
<div class="paragraph">
<p>Das ist wichtig wenn eine dynamisch geladene Bibliothek direkten Speicherzugriff auf Datenstrukturen des ladenden Programmes bekommt, oder letzteres auf Speicherbereiche zugreift, die von der Shared Lib befüllt wurden.</p>
</div>
<div class="paragraph">
<p>Daraus leitet sich die erste Grundregel ab bei der Verwendung von dynamisch geladenen Bibliotheken ab:</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Host-Programm und DLLs müssen stets mit binär-compatiblen Compilern compiliert werden. Das muss nicht zwingend die gleiche Compiler-Version sein. Z.B. gilt Binärcompatibilität für eine Reihe von Visual Studio Compilern (ab 2015/VC14), siehe <a href="https://learn.microsoft.com/en-us/cpp/porting/binary-compat-2015-2017?view=msvc-170" class="bare">https://learn.microsoft.com/en-us/cpp/porting/binary-compat-2015-2017?view=msvc-170</a></p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_quelltextunterschiede_und_versionierung">1.2. Quelltextunterschiede und Versionierung</h3>
<div class="paragraph">
<p>Software "lebt" und wird weiterentwickelt. Dies gilt für Plugins und für das eigentliche Hauptprogramm gleichermaßen. Die Trennung von Plugin und Hauptsoftware hat ja auch den Grund, dass ein (externer) Pluginentwickler eigene, vom Hauptprogramm unabhängige Release-Zyklen haben kann und z.B. ein Plugin auch für mehrere Hauptprogrammversionen gültig sein kann. Allerdings sind Hauptprogramm und Plugin nicht komplett unabhängig, wenn Sie gemeinschaftlich auf Daten im Speicher zugreifen bzw. komplexe Objekte austauschen.</p>
</div>
<div class="paragraph">
<p>Die größte Unabhängigkeit zwischen Plugin und Hauptprogramm erreicht man, wenn man:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>keine komplexen Datentypen zum Datenaustausch nutzt, sondern ausschließlich einfache Datentypen (<em>PODs - plain old data types</em>) wie int, bool, double, char austauschen. Ein <code>std::string</code> ist bereits ein komplexer Datentyp, sodass zum Austausch von Zeichenketten meist nur ein <code>const char *</code> verwendet wird.</p>
</li>
<li>
<p>keinen gegenseitigen Speicherzugriff auf den jeweiligen Datenbereich des Plugins oder Hauptprogramms erlaubt</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Allerdings ist das für umfangreichere (also quasi alle sinnvollen) Plugins <strong><em>nicht praktikabel</em></strong>. Es müssen also zwischen Veränderungen des Quelltextes gegenüber einer einheitlichen Ausgangsvariante, mit der sowohl Hauptprogramm als auch Plugin compiliert wurden, erkannt und behandelt werden.</p>
</div>
<div class="sect3">
<h4 id="_fall_1_gemeinsam_genutzte_datenstruktur_im_hauptprogramm_ändert_sich">1.2.1. Fall 1: Gemeinsam genutzte Datenstruktur im Hauptprogramm ändert sich</h4>
<div class="paragraph">
<p>Dies ist einer der häufigten Fälle und betrifft im Fall von SIM-VICUS zumeist das Datenmodell in der <em>VICUS</em> Bibliothek und dadurch auch <em>NANDRAD</em> und die <em>IBK</em> Libs (und alle anderen Bibliotheken, die Datenstrukturen von Membervariablen innerhalb von <code>VICUS::Project</code> deklarieren).</p>
</div>
<div class="paragraph">
<p>Nehmen wir an, es gibt eine Veränderung in einer Klasse <code>PlainGeometry</code> wie im <a href="#ex_plainGeometry">Beispiel 2</a> gezeigt.</p>
</div>
<div id="ex_plainGeometry" class="exampleblock">
<div class="title">Beispiel 2. Typische Erweiterung einer Datenstruktur während des Entwicklungsprozesses; hierbei wird eine neue Membervariable <code>m_displayName</code> hinzugefügt, welche die bisherigen Membervariablen innerhalb des Objekts im Speicher nach hinten verschiebt.</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="c1">// Ursprungsversion</span>
<span class="k">class</span> <span class="nc">PlainGeometry</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="c1">// ...</span>

    <span class="cm">/*! Polygons with holes/subsurfaces inside the polygon. */</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Surface</span><span class="o">&gt;</span>                        <span class="n">m_surfaces</span><span class="p">;</span>             <span class="c1">// XML:E</span>
    <span class="cm">/*! Indicates whether all children elements are visible. */</span>
    <span class="kt">bool</span>                                        <span class="n">m_visible</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>       <span class="c1">// XML:A</span>
    <span class="cm">/*! Indicates whether all children elements are selected. */</span>
    <span class="kt">bool</span>                                        <span class="n">m_selected</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">};</span>



<span class="c1">// Neue Version</span>
<span class="k">class</span> <span class="nc">PlainGeometry</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="c1">// ...</span>

    <span class="cm">/*! Descriptive name. */</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span>                                 <span class="n">m_displayName</span><span class="p">;</span>          <span class="c1">// XML:A</span>
    <span class="cm">/*! Polygons with holes/subsurfaces inside the polygon. */</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Surface</span><span class="o">&gt;</span>                        <span class="n">m_surfaces</span><span class="p">;</span>             <span class="c1">// XML:E</span>
    <span class="cm">/*! Indicates whether all children elements are visible. */</span>
    <span class="kt">bool</span>                                        <span class="n">m_visible</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>       <span class="c1">// XML:A</span>
    <span class="cm">/*! Indicates whether all children elements are selected. */</span>
    <span class="kt">bool</span>                                        <span class="n">m_selected</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Nehmen wir mal an, das Plugin wurde mit der Ursprungsversion kompiliert und das Hauptprogramm bereits mit der neuen Version. Nun wird das Plugin geladen, erhält vom Hauptprogramm die Adresse eines <code>PlainGeometry</code> Objekts und greift auf die Membervariable <code>m_surfaces</code> zu. Im Quelltext des Plugins stand diese Variable an erster Stelle (offset 0), allerdings steht im Speicher des vom Hauptprogramm übergebenen Objekts nun ein String (beim offset 0). Beim Zugriff und Auswertung des Speicherbereichs wird das Plugin nun string-Daten als vector interpretieren und mit hoher Wahrscheinlichkeit mit einer Access Violoation/SEGFAULT crashen.</p>
</div>
<div class="paragraph">
<p><strong>Das Problem:</strong> sowohl das Hauptprogramm als auch das Plugin können derartige Unterschiede nicht einfach erkennen (die Prüfung der binäre Struktur aller beteiligter Klassen ist quasi unmöglich).</p>
</div>
<div class="paragraph">
<p><strong>Lösung:</strong> Das Hauptprogramm muss anhand von <em>Plugin-Metadaten</em> feststellen, ob das Plugin mit der gleichen Datenstruktur-Version kompiliert wurde.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Plugins müssen Metadaten mitliefern, die Auskunft über die verwendeten Datenstrukturversionen bzw. Bibliotheksversionen geben.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Ein Beispiel für solche Metadaten wäre, wenn das Plugin mitteilt, für welche Hauptprogrammversionen (=Datenstrukturversion) ein Plugin anzuwenden ist, also beispielsweise <code>SIM-VICUS-Versions = 0.9.4</code>. In der Regel ist dies immer exakt eine SIM-VICUS Release-Version. Bei der Veröffentlichung der nächsten Version würden daher alle alten Plugins automatisch deaktiviert, d.h. nicht geladen werden.</p>
</div>
<div class="paragraph">
<p>Da ein Plugin jedoch meist nur Teile einer Datenstruktur verwendet, kann es bei bestimmten Datenstrukturänderungen durchaus möglich sein, ein älteres Plugin weiter zu verwenden. Ein Beispiel dafür wäre ein Plugin, welches mit Materialdaten arbeitet. Wenn in der Datenstruktur lediglich Änderungen an Netzwerkklassen vorgenommen werden, dann sind derartige Versionsänderungen für das Plugin unwichtig. Das kompilierte Plugin kann auch bei neueren Versionen des Hauptprogramms weiter verwendet werden - man muss nur die Metadaten anpassen. In diesem Fall würde man den Zulässigkeitsbereich des Plugins auf die nächste Hauptprogrammversion erweitern, z.B. <code>SIM-VICUS-Versions = 0.9.4..0.9.5</code>.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Achtung"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Die Pflege der Metadaten und Kompatibilitätsversionen ist für korrekt funktionierende Plugins kritisch!</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_fall_2_plugin_schnittstelle_ändert_sich">1.2.2. Fall 2: Plugin-Schnittstelle ändert sich</h4>
<div class="paragraph">
<p>Unter <em>Plugin-Schnittstelle</em> versteht man die Deklaration der Funktionen, die im Plugin seitens des Hauptprogramms aufgerufen werden. <a href="#ex_PluginInterface">Beispiel 3</a> zeigt eine solche Schnittstelle für ein Datenbank-Plugin.</p>
</div>
<div id="ex_PluginInterface" class="exampleblock">
<div class="title">Beispiel 3. Plugin-Schnittstellen-Deklaration</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="cm">/*! Interface for a plugin that provides VICUS database elements. */</span>
<span class="k">class</span> <span class="nc">SVDatabasePluginInterface</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="cm">/*! Virtual D'tor. */</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">SVDatabasePluginInterface</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

    <span class="cm">/*! Returns a title text for the plugin, used in the main menu for settings and
        for info/error messages. Used like "Configure xxxx..." and "About xxxx...".
    */</span>
    <span class="k">virtual</span> <span class="n">QString</span> <span class="n">title</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="cm">/*! This function needs to be implemented by the database plugin to populate the database with its own data.
    */</span>
    <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">retrieve</span><span class="p">(</span><span class="k">const</span> <span class="n">SVDatabase</span> <span class="o">&amp;</span> <span class="n">currentDB</span><span class="p">,</span> <span class="n">SVDatabase</span> <span class="o">&amp;</span> <span class="n">augmentedDB</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define SVDatabasePluginInterface_iid "ibk.sim-vicus.Plugin.DatabaseInterface/1.0"
</span>
<span class="n">Q_DECLARE_INTERFACE</span><span class="p">(</span><span class="n">SVDatabasePluginInterface</span><span class="p">,</span> <span class="n">SVDatabasePluginInterface_iid</span><span class="p">)</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Bei einer solchen Schnittstellendeklaration handelt es sich einfach um eine Klasse mit virtuellen Memberfunktionen. Diese Schnittstelle wird vom konkreten Plugin geerbt und implementiert (im Plugin-Quelltext). Die Schnittstellendeklaration teilt dem Hauptprogramm lediglich mit, welche Funktionen mit welchen Argumenten vom Plugin zur Verfügung gestellt werden.</p>
</div>
<div class="paragraph">
<p>Wenn das Hauptprogramm nun eine dynamische Bibliothek lädt, dann wird zunächst nur ein Zeiger auf die Klassenschnittstelle (das Objekt des Plugins) geladen. Das Hauptprogramm könnte nun mittels <code>dynamic_cast</code> prüfen, ob es sich um ein Plugin einer bestimmten Schnittstellendeklaration handelt:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="kt">void</span> <span class="o">*</span> <span class="n">ptrToPlugin</span> <span class="o">=</span> <span class="p">...</span> <span class="p">;</span> <span class="c1">// Zeiger hält Plugin-Objekt-Adresse</span>

<span class="n">SVDatabasePluginInterface</span> <span class="o">*</span> <span class="n">dbPlugin</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">SVDatabasePluginInterface</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">ptrToPlugin</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">dbPlugin</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// es ist ein DB-Plugin!</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Eine Schnittstellendeklaration ändert sich z.B. dann, wenn das Hauptprogramm eine neue Funktion für das Plugin oder ein verändertes Verhalten unterstützt. Im Gegensatz zur Fall 1 oben muss das nicht zwingend eine Datenstrukturänderung bedingen, es kann z.B. einfach ein neues Argument sein, was zu einer deklarierten Funktion hinzugefügt wird.</p>
</div>
<div class="paragraph">
<p><strong>Das Problem:</strong> Wenn sich innerhalb der Deklaration von <code>SVDatabasePluginInterface</code> eine Memberfunktion ändert, z.B. die Argumente geändert werden oder neue Funktionen hinzugefügt werden, dann ändert sich dadurch nicht der Typ des Objekts. D.h. der <code>dynamic_cast</code> liefert weiterhin eine gültige Adresse.  Wenn nun das Hauptprogramm mittels dieser Adresse eine neue Memberfunktion (deklariert in einer neuen Version der Pluginschnittstelle im Hauptprogramm) im Plugin (kompiliert mit alter Schnittstelle) aufruft, führt dies zu einer Access Violation/SEGFAULT.</p>
</div>
<div class="paragraph">
<p><strong>Die Lösung:</strong> Die Schnittstelle, d.h. die gesamte Deklaration der Schnittstelle muss seitens des Hauptprogramms bei der Zeigerkonvertierung auf Passgenauigkeit geprüft werden. Dies gelingt <em>nicht</em> mit <code>dynamic_cast</code>, jedoch bietet Qt die Möglichkeit, mittels <code>qobject_cast</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">SVDatabasePluginInterface</span> <span class="o">*</span> <span class="n">dbPlugin</span> <span class="o">=</span> <span class="n">qobject_cast</span><span class="o">&lt;</span><span class="n">SVDatabasePluginInterface</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">ptrToPlugin</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Die <code>qobject_cast</code>-Funktion prüft dabei zusätzlich noch die Interface-ID, welche mit</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="cp">#define SVDatabasePluginInterface_iid "ibk.sim-vicus.Plugin.DatabaseInterface/1.0"
</span>
<span class="n">Q_DECLARE_INTERFACE</span><span class="p">(</span><span class="n">SVDatabasePluginInterface</span><span class="p">,</span> <span class="n">SVDatabasePluginInterface_iid</span><span class="p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>festgelegt wird. Nehmen wir mal an, dass das Plugin kompiliert wird und dabei die Interface-ID als <code>ibk.sim-vicus.Plugin.DatabaseInterface/1.0</code> festgelegt wird. Nun ändert sich die Schnittstelle im Hauptprogramm und seitens des Hauptprogramms wird die Versionsnummer auf <code>ibk.sim-vicus.Plugin.DatabaseInterface/2.0</code> erhöht. Beim Einladen des Plugins mit der alten Schnittstelle liefert der <code>qobject_cast</code> nun wegen unpassender Interface-IDs einen n ullptr zurück. Dadurch kann man absichern, dass die Schnittstelle zum Zeitpunkt der Plugin- und Hauptprogramm-Kompilierung identisch sind.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Sobald man die Schnittstelle eines Plugins (oder Elternklasse) im Hauptprogramm ändert, muss man die Interface-ID anpassen!</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 1.0 (31.12.2022)<br>
Last updated 2022-12-31 12:44:07 +0100
</div>
</div>
</body>
</html>