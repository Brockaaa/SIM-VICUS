/*	NANDRAD Solver Framework and Model Implementation.

	Copyright (c) 2012-today, Institut für Bauklimatik, TU Dresden, Germany

	Primary authors:
	  Andreas Nicolai  <andreas.nicolai -[at]- tu-dresden.de>
	  Anne Paepcke     <anne.paepcke -[at]- tu-dresden.de>

	This program is part of SIM-VICUS (https://github.com/ghorwin/SIM-VICUS)

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.
*/

#include "NM_HydraulicNetworkFlowElements.h"

#include <NANDRAD_HydraulicNetworkElement.h>
#include <NANDRAD_HydraulicNetworkPipeProperties.h>
#include <NANDRAD_HydraulicNetworkComponent.h>
#include <NANDRAD_HydraulicNetworkControlElement.h>
#include <NANDRAD_HydraulicFluid.h>
#include <NANDRAD_Thermostat.h>

#include <IBK_FluidPhysics.h>

#include <algorithm>
#include <numeric>

#include "NM_Controller.h"

#define PI				3.141592653589793238

const double MASS_FLUX_SCALE = 1000.;

namespace NANDRAD_MODEL {

// Definition of destructor is here, so that we have the code and virtual function table
// only once.
HydraulicNetworkAbstractFlowElement::~HydraulicNetworkAbstractFlowElement() {
}


// *** HNPipeElement ***

HNPipeElement::HNPipeElement(const NANDRAD::HydraulicNetworkElement & elem,
							const NANDRAD::HydraulicNetworkPipeProperties & pipePara,
							const NANDRAD::HydraulicFluid & fluid,
							const NANDRAD::HydraulicNetworkControlElement *controller,
							const std::vector<NANDRAD::Thermostat> & thermostats):
	m_fluid(&fluid),
	m_controlElement(controller),
	m_thermostats(thermostats)
{
	m_length = elem.m_para[NANDRAD::HydraulicNetworkElement::P_Length].value;
	m_diameter = pipePara.m_para[NANDRAD::HydraulicNetworkPipeProperties::P_PipeInnerDiameter].value;
	m_roughness = pipePara.m_para[NANDRAD::HydraulicNetworkPipeProperties::P_PipeRoughness].value;
	m_nParallelPipes = (unsigned int) elem.m_intPara[NANDRAD::HydraulicNetworkElement::IP_NumberParallelPipes].value;
}


void HNPipeElement::modelQuantities(std::vector<QuantityDescription> & quantities) const{
	quantities.push_back(QuantityDescription("PressureDifferencePerLength","Pa/m", "The pressure difference per m pipe length", false));
	if(m_controlElement == nullptr)
		return;
	// calculate zetaControlled value for valve
	quantities.push_back(QuantityDescription("ControllerResultValue","---", "The calculated controller zeta value for the valve", false));
}


void HNPipeElement::modelQuantityValueRefs(std::vector<const double *> & valRefs) const {
	valRefs.push_back(&m_pressureLossPerLength);
	// calculate zetaControlled value for valve
	if(m_controlElement != nullptr)
		valRefs.push_back(&m_zetaControlled);
}


void HNPipeElement::inputReferences(std::vector<InputReference> & inputRefs) const {
	// in the case of control add heat exchange spline value to input references
	if (m_controlElement != nullptr) {
		// loop over all models, pick out the Thermostat-models and request input for a single zone. Later we check
		// that one (and exactly) one request must be fulfilled!
		for (const NANDRAD::Thermostat &thermostat : m_thermostats ) {
			// create an input reference to heating and cooling control values for all the constructions that we heat
			InputReference inputRef;
			inputRef.m_id = thermostat.m_id;
			inputRef.m_referenceType = NANDRAD::ModelInputReference::MRT_MODEL;
			inputRef.m_name.m_name = "HeatingControlValue";
			inputRef.m_name.m_index = (int) m_controlElement->m_idReferences[NANDRAD::HydraulicNetworkControlElement::ID_ThermostatZoneId]; // vector gets ID of requested zone
			inputRef.m_required = false;
			inputRefs.push_back(inputRef);
			inputRef.m_name.m_name = "CoolingControlValue";
			inputRefs.push_back(inputRef);
		}
	}
}


void HNPipeElement::setInputValueRefs(std::vector<const double*>::const_iterator & resultValueRefs) {
	FUNCID(HNPipeElement::setInputValueRefs);

	// in the case of control add heat exchange spline value to input references
	if (m_controlElement == nullptr)
		return;

	// now store the pointer returned for our input ref request and advance the iterator by one
	// m_heatingThermostatValueRef and m_coolingThermostatValueRef are initially nullptr -> not set
	for (unsigned int i=0; i< m_thermostats.size(); ++i) {
		// heating control value
		if (*resultValueRefs != nullptr) {
			// we must not yet have a reference!
			if (m_heatingThermostatControlValueRef != nullptr)
				throw IBK::Exception(IBK::FormatString("Duplicate heating control value result generated by different thermostats "
													   "for zone id=%1.")
									 .arg(m_controlElement->m_idReferences[NANDRAD::HydraulicNetworkControlElement::ID_ThermostatZoneId]), FUNC_ID);
			m_heatingThermostatControlValueRef = *resultValueRefs;
		}
		++resultValueRefs;
		// cooling control value
		if (*resultValueRefs != nullptr) {
			// we must not yet have a reference!
			if( m_coolingThermostatControlValueRef != nullptr)
				throw IBK::Exception(IBK::FormatString("Duplicate cooling control value result generated by different thermostats "
													   "for zone id=%1.")
									 .arg(m_controlElement->m_idReferences[NANDRAD::HydraulicNetworkControlElement::ID_ThermostatZoneId]), FUNC_ID);
			m_coolingThermostatControlValueRef = *resultValueRefs;
		}
		++resultValueRefs;
	}
}


void HNPipeElement::dependencies(const double * mdot, std::vector<std::pair<const double *, const double *> > & resultInputDependencies) const {
	// here we define dependencies between mdot and controller-inputs
	if (m_heatingThermostatControlValueRef != nullptr)
		resultInputDependencies.push_back(std::make_pair(mdot, m_heatingThermostatControlValueRef) );
	if (m_coolingThermostatControlValueRef != nullptr)
		resultInputDependencies.push_back(std::make_pair(mdot, m_coolingThermostatControlValueRef) );
}


double  HNPipeElement::systemFunction(double mdot, double p_inlet, double p_outlet) const {
#if 0
	// test implementation of special bypass-pipe model
	if (m_diameter > 0.0049 && m_diameter < 0.0051) {
		const double MDOT_GEGEBEN = 0.02;
		double zeta = MDOT_GEGEBEN/(mdot+1e-10);
		zeta *= zeta;
		zeta *= zeta;
		zeta *= 100000000;
		double deltaP = zeta * std::abs(mdot) * mdot;
		const double DP_MAX = 2750.0;
		deltaP = std::min(deltaP, DP_MAX);
		return p_inlet - p_outlet - deltaP;
	}
#endif
	// In case of multiple parallel pipes, mdot is the mass flux through *all* pipes
	// (but all parallel sections together need the same pressure drop as a single one
	double deltaP = pressureLossFriction(mdot/m_nParallelPipes);
	return p_inlet - p_outlet - deltaP;	// this is the system function
}


void HNPipeElement::partials(double mdot, double p_inlet, double p_outlet,
							 double & df_dmdot, double & df_dp_inlet, double & df_dp_outlet) const
{
	// partial derivatives of the system function to pressures are constants
	df_dp_inlet = 1;
	df_dp_outlet = -1;

	// generic DQ approximation of partial derivative
	const double EPS = 1e-5; // in kg/s
	double f_eps = systemFunction(mdot+EPS, p_inlet, p_outlet);
	double f = systemFunction(mdot, p_inlet, p_outlet);
	df_dmdot = (f_eps - f)/EPS;
}


double HNPipeElement::pressureLossFriction(const double &mdot) const {
	// for negative mass flow: Reynolds number is positive, velocity and pressure loss are negative
	double fluidDensity = m_fluid->m_para[NANDRAD::HydraulicFluid::P_Density].value;
	double velocity = mdot / (fluidDensity * m_diameter * m_diameter * PI / 4.0);
	double Re = std::abs(velocity) * m_diameter / m_fluid->m_kinematicViscosity.m_values.value(*m_fluidTemperatureRef);
	double zeta = m_length / m_diameter * IBK::FrictionFactorSwamee(Re, m_diameter, m_roughness);

	// add controlled zeta
	if (m_controlElement != nullptr)
		zeta += zetaControlled();

	return zeta * fluidDensity / 2.0 * std::abs(velocity) * velocity;
}


double HNPipeElement::zetaControlled() const {
	// valve is closed by default
	double heatingControlValue = m_controlElement->m_maximumControllerResultValue;
	double coolingControlValue = m_controlElement->m_maximumControllerResultValue;

	// get control value for heating
	if (m_heatingThermostatControlValueRef != nullptr) {
		// het heating control value and clip to the range of 0..1
		// 0 - no heating required (above setpoint)
		// 1 - max. heating required (for p-controller, the defined allowed tolerance has been reached
		//     for example, if Thermostat tolerance in set to 0.1 K, and the temperature difference to
		//     the setpoint is >= 0.1 K, heatingControlValue will be 1
		heatingControlValue = std::min(std::max(*m_heatingThermostatControlValueRef, 0.0), 1.0);

		// if heating is required, we open the valve:
		//   heatingControlValue = 1  -> zetaControlled = 0
		// if no heating is required, we close the valve
		//   heatingControlValue = 0  -> zetaControlled = m_maximumControllerResultValue
		// in between we interpolate linearly
		double e = (1.0 - heatingControlValue);
		heatingControlValue = m_controlElement->m_para[NANDRAD::HydraulicNetworkControlElement::P_Kp].value * e; // std::pow(10.,-2*(1-e));
		// clip against max value
		heatingControlValue = std::min(heatingControlValue, m_controlElement->m_maximumControllerResultValue);
	}

	// get control value for cooling
	if (m_coolingThermostatControlValueRef != nullptr) {
		// TODO : same as for heating
		coolingControlValue = std::min(std::max(*m_coolingThermostatControlValueRef, 0.0), 1.0);
		double e = (1.0 - coolingControlValue);
		coolingControlValue = m_controlElement->m_maximumControllerResultValue * e;
	}

	// either cooling or heating may require opening of the value
	// we take the lesser of the selected additional resistances
	return std::min(heatingControlValue, coolingControlValue);
}


void HNPipeElement::updateResults(double mdot, double /*p_inlet*/, double /*p_outlet*/) {
	m_pressureLossPerLength = pressureLossFriction(mdot/m_nParallelPipes) / m_length;
	// calculate zetaControlled value for valve
	if (m_controlElement != nullptr) {
		m_zetaControlled = zetaControlled();
	}
}




// *** HNPressureLossCoeffElement ***

HNPressureLossCoeffElement::HNPressureLossCoeffElement(unsigned int flowElementId,
														const NANDRAD::HydraulicNetworkComponent &component,
														const NANDRAD::HydraulicFluid &fluid,
														const NANDRAD::HydraulicNetworkControlElement *controlElement,
														unsigned int numberParallelElements):
	m_id(flowElementId),
	m_numberParallelElements(numberParallelElements),
	m_controlElement(controlElement)
{
	m_fluidDensity = fluid.m_para[NANDRAD::HydraulicFluid::P_Density].value;
	m_fluidHeatCapacity = fluid.m_para[NANDRAD::HydraulicFluid::P_HeatCapacity].value;
	m_zeta = component.m_para[NANDRAD::HydraulicNetworkComponent::P_PressureLossCoefficient].value;
	m_diameter = component.m_para[NANDRAD::HydraulicNetworkComponent::P_HydraulicDiameter].value;

	// add controller object
	if (controlElement != nullptr){
		switch (controlElement->m_controllerType) {
			case NANDRAD::HydraulicNetworkControlElement::CT_PController: {
				PController *cont = new PController();
				cont->m_kP = controlElement->m_para[NANDRAD::HydraulicNetworkControlElement::P_Kp].value;
				m_controller = cont;
			} break;
			case NANDRAD::HydraulicNetworkControlElement::CT_PIController: {
				PIController *cont = new PIController();
				cont->m_kP = controlElement->m_para[NANDRAD::HydraulicNetworkControlElement::P_Kp].value;
				cont->m_kI = controlElement->m_para[NANDRAD::HydraulicNetworkControlElement::P_Ki].value;
				m_controller = cont;
			} break;
			case NANDRAD::HydraulicNetworkControlElement::CT_PIDController: {
				PIDController *cont = new PIDController();
				cont->m_kP = controlElement->m_para[NANDRAD::HydraulicNetworkControlElement::P_Kp].value;
				cont->m_kI = controlElement->m_para[NANDRAD::HydraulicNetworkControlElement::P_Ki].value;
				cont->m_kD = controlElement->m_para[NANDRAD::HydraulicNetworkControlElement::P_Kd].value;
				m_controller = cont;
			} break;
			case NANDRAD::HydraulicNetworkControlElement::CT_OnOffController: // not a valid combination
			case NANDRAD::HydraulicNetworkControlElement::NUM_CT:
				break;
		}
		IBK_ASSERT(m_controller != nullptr);
		// we never want zeta values below zero
		m_controller->m_controlValueMinimum = 0;
		// set maximum zeta value
		if (m_controlElement->m_maximumControllerResultValue > 0)
			m_controller->m_controlValueMaximum = m_controlElement->m_maximumControllerResultValue;
	}

	// initialize set point pointers, in case of scheduled parameters the pointers will be updated in setInputValueRefs()
	m_temperatureDifferenceSetpointRef = &m_controlElement->m_para[NANDRAD::HydraulicNetworkControlElement::P_TemperatureDifferenceSetpoint].value;
	m_massFluxSetpointRef = &m_controlElement->m_para[NANDRAD::HydraulicNetworkControlElement::P_MassFluxSetpoint].value;
}


HNPressureLossCoeffElement::~HNPressureLossCoeffElement() {
	delete m_controller;
}


void HNPressureLossCoeffElement::inputReferences(std::vector<InputReference> & inputRefs) const {
	if (m_controlElement == nullptr)
		return; 	// only handle input reference when there is a controller

	switch (m_controlElement->m_controlledProperty) {

		case NANDRAD::HydraulicNetworkControlElement::CP_TemperatureDifference: {
			InputReference ref;
			ref.m_id = m_id;
			ref.m_referenceType = NANDRAD::ModelInputReference::MRT_NETWORKELEMENT;
			ref.m_name.m_name = "HeatExchangeHeatLoss";
			ref.m_required = true;
			inputRefs.push_back(ref);
			// if we have a scheduled temperature difference setpoint, also generate input reference for
			// the scheduled value
			if (m_controlElement->m_modelType == NANDRAD::HydraulicNetworkControlElement::MT_Scheduled) {
				InputReference ref;
				ref.m_id = m_id;
				ref.m_referenceType = NANDRAD::ModelInputReference::MRT_NETWORKELEMENT;
				ref.m_name.m_name = "TemperatureDifferenceSetpointSchedule";
				ref.m_required = true;
				inputRefs.push_back(ref);
			}
		} break;

		case NANDRAD::HydraulicNetworkControlElement::CP_TemperatureDifferenceOfFollowingElement: {
			InputReference ref;
			ref.m_id = m_followingflowElementId;
			ref.m_referenceType = NANDRAD::ModelInputReference::MRT_NETWORKELEMENT;
			ref.m_name.m_name = "FluidTemperature";
			ref.m_required = true;
			inputRefs.push_back(ref);
			// if we have a scheduled temperature difference setpoint, also generate input reference for
			// the scheduled value
			if (m_controlElement->m_modelType == NANDRAD::HydraulicNetworkControlElement::MT_Scheduled) {
				InputReference ref;
				ref.m_id = m_id;
				ref.m_referenceType = NANDRAD::ModelInputReference::MRT_NETWORKELEMENT;
				ref.m_name.m_name = "TemperatureDifferenceSetpointSchedule";
				ref.m_required = true;
				inputRefs.push_back(ref);
			}
		} break;

		case NANDRAD::HydraulicNetworkControlElement::CP_MassFlux: {
			// only create input reference for scheduled variant
			if (m_controlElement->m_modelType == NANDRAD::HydraulicNetworkControlElement::MT_Scheduled) {
				InputReference ref;
				ref.m_id = m_id;
				ref.m_referenceType = NANDRAD::ModelInputReference::MRT_NETWORKELEMENT;
				ref.m_name.m_name = "MassFluxSetpointSchedule";
				ref.m_required = true;
				inputRefs.push_back(ref);
			}
		} break;
		default: ; // other control elements do not require inputs
	}
}


void HNPressureLossCoeffElement::setInputValueRefs(std::vector<const double*>::const_iterator & resultValueRefs) {
	if (m_controlElement == nullptr)
		return; 	// only handle input reference when there is a controller

	switch (m_controlElement->m_controlledProperty) {
		case NANDRAD::HydraulicNetworkControlElement::CP_TemperatureDifference :
			// now store the pointer returned for our input ref request and advance the iterator by one
			m_heatExchangeHeatLossRef = *(resultValueRefs++); // Heat exchange value reference
			// scheduled variant?
			if (m_controlElement->m_modelType == NANDRAD::HydraulicNetworkControlElement::MT_Scheduled)
				m_temperatureDifferenceSetpointRef = *(resultValueRefs++);
		break;

		case NANDRAD::HydraulicNetworkControlElement::CP_TemperatureDifferenceOfFollowingElement :
			// now store the pointer returned for our input ref request and advance the iterator by one
			m_followingFlowElementFluidTemperatureRef = *(resultValueRefs++); // Fluid temperature of following element
			// scheduled variant?
			if (m_controlElement->m_modelType == NANDRAD::HydraulicNetworkControlElement::MT_Scheduled)
				m_temperatureDifferenceSetpointRef = *(resultValueRefs++);
		break;

		case NANDRAD::HydraulicNetworkControlElement::CP_MassFlux: {
			// scheduled variant?
			if (m_controlElement->m_modelType == NANDRAD::HydraulicNetworkControlElement::MT_Scheduled)
				m_massFluxSetpointRef = *(resultValueRefs++);
		} break;
		default: ; // other control elements do not require inputs
	}
}


void HNPressureLossCoeffElement::dependencies(const double * mdot,
											  std::vector<std::pair<const double *, const double *> > & resultInputDependencies) const
{
	if (m_controlElement == nullptr)
		return;
	switch (m_controlElement->m_controlledProperty) {
		case NANDRAD::HydraulicNetworkControlElement::CP_TemperatureDifference:
			resultInputDependencies.push_back(std::make_pair(mdot, m_heatExchangeHeatLossRef) );
		break;

		case NANDRAD::HydraulicNetworkControlElement::CP_TemperatureDifferenceOfFollowingElement:
			resultInputDependencies.push_back(std::make_pair(mdot, m_fluidTemperatureRef) );
			resultInputDependencies.push_back(std::make_pair(mdot, m_followingFlowElementFluidTemperatureRef) );
		break;

		case NANDRAD::HydraulicNetworkControlElement::CP_MassFlux: {
			resultInputDependencies.push_back(std::make_pair(mdot, m_massFluxSetpointRef) );
		}
		break;

		case NANDRAD::HydraulicNetworkControlElement::CP_ThermostatValue:
		case NANDRAD::HydraulicNetworkControlElement::CP_PumpOperation:
		case NANDRAD::HydraulicNetworkControlElement::CP_PressureDifferenceWorstpoint:
		case NANDRAD::HydraulicNetworkControlElement::NUM_CP: ;
	}
}


void HNPressureLossCoeffElement::modelQuantities(std::vector<QuantityDescription> & quantities) const{
	if (m_controlElement == nullptr)
		return;
	// calculate zetaControlled value for valve
	quantities.push_back(QuantityDescription("ControllerResultValue","---", "The calculated controller zeta value for the valve", false));
	quantities.push_back(QuantityDescription("ControllerErrorValue","---", "The calculated controller zeta value for the valve", false));
}


void HNPressureLossCoeffElement::modelQuantityValueRefs(std::vector<const double *> & valRefs) const {
	if (m_controlElement == nullptr)
		return;
	// calculate zetaControlled value for valve
	valRefs.push_back(&m_zetaControlled);
	valRefs.push_back(&m_controllerError);
}



double HNPressureLossCoeffElement::systemFunction(double mdot, double p_inlet, double p_outlet) const {
	// for negative mass flow: dp is negative
	double area = PI / 4 * m_diameter * m_diameter;
	double velocity = mdot / (m_fluidDensity * area * m_numberParallelElements); // signed!
	double zeta = m_zeta;
	if (m_controlElement != nullptr)
		zeta += zetaControlled(mdot); // no clipping necessary here, function zetaControlled() takes care of that!

	double dp = zeta * m_fluidDensity / 2 * std::abs(velocity) * velocity;
	return p_inlet - p_outlet - dp;
}


double HNPressureLossCoeffElement::zetaControlled(double mdot) const {

	double e = 0;		// controller error
	double temperatureDifference = 0;

	// calculate zetaControlled value for valve
	switch (m_controlElement->m_controlledProperty) {

		case NANDRAD::HydraulicNetworkControlElement::CP_TemperatureDifference:
		case NANDRAD::HydraulicNetworkControlElement::CP_TemperatureDifferenceOfFollowingElement: {

			// -> CP_TemperatureDifference
			if (m_controlElement->m_controlledProperty == NANDRAD::HydraulicNetworkControlElement::CP_TemperatureDifference) {
				IBK_ASSERT(m_heatExchangeHeatLossRef != nullptr);
				// compute current temperature for given heat loss and mass flux
				// Mind: access m_heatExchangeValueRef and not m_heatLoss here!
				temperatureDifference = *m_heatExchangeHeatLossRef/(mdot*m_fluidHeatCapacity);
			}
			// -> CP_TemperatureDifferenceOfFollowingElement
			else {
				// compute temperature difference of the following element. We already know that the node between this
				// and the following element is not connected to any other flow element
				IBK_ASSERT(m_followingFlowElementFluidTemperatureRef != nullptr);
				temperatureDifference = (*m_fluidTemperatureRef - *m_followingFlowElementFluidTemperatureRef);
			}
			// if temperature difference is larger than the set point (negative e), we want maximum mass flux -> zeta = 0
			// if temperature difference is smaller than the set point (positive e), we decrease mass flow by increasing zeta
			e = *m_temperatureDifferenceSetpointRef - temperatureDifference;

		} break;

		case NANDRAD::HydraulicNetworkControlElement::CP_MassFlux: {
			// e is > 0 if our mass flux exceeds the limit -> then we have to increase the flow resistance
			e = mdot - *m_massFluxSetpointRef;
		} break;

		case NANDRAD::HydraulicNetworkControlElement::CP_ThermostatValue: // not a possible combination
		case NANDRAD::HydraulicNetworkControlElement::CP_PumpOperation: // not a possible combination
		case NANDRAD::HydraulicNetworkControlElement::CP_PressureDifferenceWorstpoint:
		case NANDRAD::HydraulicNetworkControlElement::NUM_CP:  // nothing todo - we return 0
			return 0;
	}

	// update controller value and obtain result
	m_controller->update(e);

	return m_controller->m_controlValue;
}


void HNPressureLossCoeffElement::partials(double mdot, double p_inlet, double p_outlet,
							 double & df_dmdot, double & df_dp_inlet, double & df_dp_outlet) const
{
	// partial derivatives of the system function to pressures are constants
	df_dp_inlet = 1;
	df_dp_outlet = -1;
	// generic DQ approximation of partial derivative
	const double EPS = 1e-5; // in kg/s
	double f_eps = systemFunction(mdot+EPS, p_inlet, p_outlet);
	double f = systemFunction(mdot, p_inlet, p_outlet);
	df_dmdot = (f_eps - f)/EPS;
}


void HNPressureLossCoeffElement::updateResults(double mdot, double /*p_inlet*/, double /*p_outlet*/) {
	if (m_controlElement == nullptr)
		return;

	// calculate zetaControlled value for valve
	switch (m_controlElement->m_controlledProperty) {
		case NANDRAD::HydraulicNetworkControlElement::CP_TemperatureDifference:
		case NANDRAD::HydraulicNetworkControlElement::CP_TemperatureDifferenceOfFollowingElement:
		case NANDRAD::HydraulicNetworkControlElement::CP_MassFlux:{
			m_zetaControlled = zetaControlled(mdot);
			m_controllerError = m_controller->m_errorValue;
		}
		break;

		case NANDRAD::HydraulicNetworkControlElement::CP_ThermostatValue: // not a possible combination
		case NANDRAD::HydraulicNetworkControlElement::CP_PumpOperation: // not a possible combination
		case NANDRAD::HydraulicNetworkControlElement::CP_PressureDifferenceWorstpoint:
		case NANDRAD::HydraulicNetworkControlElement::NUM_CP: ; // nothing todo - we return 0
	}
}


void HNPressureLossCoeffElement::stepCompleted(double t) {
	if (m_controller == nullptr)
		return;

	// TODO Hauke, in paper analysieren

	m_controller->stepCompleted(t);

	// Anti-windup of PI-controller: For high controller errors (e.g. >70 % of set point), i.e. when the current value is
	// very far from the setpoint, we don't use the integral part. This avoids an increase (windup) of the integral during times when
	// there is no heat flux and the temperature difference setpoint can not be reached.
	const double &relControllerErrorIntegratorReset = m_controlElement->m_para[NANDRAD::HydraulicNetworkControlElement::P_RelControllerErrorForIntegratorReset].value;
	if (relControllerErrorIntegratorReset > 0) {
		switch (m_controlElement->m_controlledProperty ) {
			case NANDRAD::HydraulicNetworkControlElement::CP_TemperatureDifference:
			case NANDRAD::HydraulicNetworkControlElement::CP_TemperatureDifferenceOfFollowingElement: {
				if (m_controller->m_errorValue > relControllerErrorIntegratorReset * *m_temperatureDifferenceSetpointRef)  {
					m_controller->resetErrorIntegral();
				}
			} break;
			case NANDRAD::HydraulicNetworkControlElement::CP_MassFlux:
				// TODO anti-windup for mass flux control ?
				break;
			case NANDRAD::HydraulicNetworkControlElement::CP_ThermostatValue:
			case NANDRAD::HydraulicNetworkControlElement::CP_PumpOperation:
			case NANDRAD::HydraulicNetworkControlElement::CP_PressureDifferenceWorstpoint:
			case NANDRAD::HydraulicNetworkControlElement::NUM_CP:
				break; // just for compiler
		}
	}
}


void HNPressureLossCoeffElement::setTime(double t) {
	if (m_controller != nullptr)
		m_controller->setTime(t);
}





// *** HNConstantPressureLossValve ***

HNConstantPressureLossValve::HNConstantPressureLossValve(unsigned int id, const NANDRAD::HydraulicNetworkComponent &component):
	m_id(id)
{
	m_pressureLossRef = &component.m_para[NANDRAD::HydraulicNetworkComponent::P_PressureLoss].value;
}


double HNConstantPressureLossValve::systemFunction(double mdot, double p_inlet, double p_outlet) const {
	if (mdot >= 0)
		return p_inlet - p_outlet - *m_pressureLossRef;
	else
		return p_inlet - p_outlet + *m_pressureLossRef;
}


void HNConstantPressureLossValve::partials(double /*mdot*/, double /*p_inlet*/, double /*p_outlet*/,
										   double & df_dmdot, double & df_dp_inlet, double & df_dp_outlet) const
{
	// partial derivatives of the system function to pressures are constants
	df_dp_inlet = 1;
	df_dp_outlet = -1;
	df_dmdot = 0;
}


void HNConstantPressureLossValve::inputReferences(std::vector<InputReference> & inputRefs) const {
	// Note: this is an automatic override and could lead to problems. However, it is explicitely documented and
	//       a warning is added about this in the model description.
	InputReference inputRef;
	inputRef.m_referenceType = NANDRAD::ModelInputReference::MRT_NETWORKELEMENT;
	inputRef.m_name = std::string("PressureLossSchedule");
	inputRef.m_required = false;
	inputRef.m_id = m_id;
	inputRefs.push_back(inputRef);

}


void HNConstantPressureLossValve::setInputValueRefs(std::vector<const double *>::const_iterator & resultValueRefIt) {
	if (*resultValueRefIt != nullptr)
		m_pressureLossRef = *resultValueRefIt; // optional, may be nullptr
	++resultValueRefIt;
}






// *** HNAbstractPowerLimitedPumpModel ***

HNAbstractPowerLimitedPumpModel::HNAbstractPowerLimitedPumpModel(const double & density, const NANDRAD::HydraulicNetworkComponent & component,
																 unsigned int numberParallelPumps) :
	m_density(density),
	m_numberParallelPumps(numberParallelPumps)
{
	if (component.m_polynomCoefficients.m_values.find("MaximumPressureHead") != component.m_polynomCoefficients.m_values.end() &&
		component.m_polynomCoefficients.m_values.find("MaximumElectricalPower") != component.m_polynomCoefficients.m_values.end()) {
		m_coefficientsDpMax = component.m_polynomCoefficients.m_values.at("MaximumPressureHead");
		m_coefficientsPelMax = component.m_polynomCoefficients.m_values.at("MaximumElectricalPower");
	}
	else if (component.m_para[NANDRAD::HydraulicNetworkComponent::P_PumpMaximumElectricalPower].value > 0) {
		m_maxEfficiency = component.m_para[NANDRAD::HydraulicNetworkComponent::P_PumpMaximumEfficiency].value;
		m_maxElectricalPower = component.m_para[NANDRAD::HydraulicNetworkComponent::P_PumpMaximumElectricalPower].value;
		m_maxPressureHeadAtZeroFlow = component.m_para[NANDRAD::HydraulicNetworkComponent::P_MaximumPressureHead].value;
	}
	// In this case, only the efficiency is given, which is assumed to be constant. No power limitation is modeled
	else {
		m_isPowerLimited = false;
		m_maxEfficiency = component.m_para[NANDRAD::HydraulicNetworkComponent::P_PumpMaximumEfficiency].value;
	}
}


double HNAbstractPowerLimitedPumpModel::maximumPressureHead(double mdot) const {
	mdot = mdot / m_numberParallelPumps;

	if (!m_isPowerLimited)
		return std::numeric_limits<double>::max();

	double Vdot = mdot/m_density;

	// polynomial for dp_max
	if (!m_coefficientsDpMax.empty())
		return m_coefficientsDpMax[0] * Vdot * Vdot + m_coefficientsDpMax[1] * Vdot + m_coefficientsDpMax[2];

	// simple linear model
	if (m_maxPressureHeadAtZeroFlow == 0. || m_maxElectricalPower == 0. )
		return std::numeric_limits<double>::max();
	else {
		// --> pressHeadMax = f (V_dot)
		double maxPressureHead = m_maxPressureHeadAtZeroFlow *
				(1 -  m_maxPressureHeadAtZeroFlow / (4 * m_maxElectricalPower * m_maxEfficiency) * Vdot );
		// should never be below zero
		if (maxPressureHead < 0)
			return 0;
		else
			return maxPressureHead;
	}

}


double HNAbstractPowerLimitedPumpModel::efficiency(double mdot, double dp) const {
	mdot = mdot / m_numberParallelPumps;

	// 0. if no power limitation is used, the efficiency is constant
	if (!m_isPowerLimited)
		return m_maxEfficiency;

	// 1. Calculate cross point of eta=const curve and dpMax curve, the result is Vdot_star
	double Vdot = mdot/m_density;
	double p,q;
	// polynomial for dp_max
	if (!m_coefficientsDpMax.empty()) {
		double c = dp / (Vdot*Vdot);
		p = m_coefficientsDpMax[1] / (m_coefficientsDpMax[0] - c);
		q = m_coefficientsDpMax[2] / (m_coefficientsDpMax[0] - c);
	}
	// simple linear model
	else {
		p = m_maxPressureHeadAtZeroFlow * m_maxPressureHeadAtZeroFlow * Vdot * Vdot / (4.0 * m_maxElectricalPower * m_maxEfficiency * dp);
		q = -m_maxPressureHeadAtZeroFlow * Vdot * Vdot / dp;
	}
	double Vdot_star = 0;
	if (p*p/4.0 - q > 0)
		Vdot_star = -p/2.0 + std::sqrt(p*p/4.0 - q);

	// 2. Calculate efficiency
	double PelMax;
	if (!m_coefficientsPelMax.empty())
		PelMax = m_coefficientsPelMax[0] * Vdot * Vdot + m_coefficientsPelMax[1] * Vdot + m_coefficientsPelMax[2];
	else
		PelMax = m_maxElectricalPower;
	double eta = maximumPressureHead(Vdot_star * m_density) * Vdot_star / PelMax;

	// is always >0
	if (eta>0)
		return eta;
	else
		return 0;
}


double HNAbstractPowerLimitedPumpModel::electricalPower(double mdot, double dp, double eta) const{
	mdot = mdot / m_numberParallelPumps;

	double Pel = 0;
	if (eta > 0)
		Pel = mdot/m_density * dp / eta;
	// Pel is always >0, if flow is backwards it is 0.
	if (Pel<0)
		Pel=0;
	// for simple linear model: cut maximum power
	if (m_isPowerLimited && m_coefficientsPelMax.empty() && Pel > m_maxElectricalPower)
		return m_numberParallelPumps * m_maxElectricalPower;
	else
		return m_numberParallelPumps * Pel;
}




// *** HNConstantPressurePump ***

HNConstantPressurePump::HNConstantPressurePump(unsigned int id, const NANDRAD::HydraulicNetworkComponent &component,
											   const NANDRAD::HydraulicFluid & fluid,
											   const NANDRAD::HydraulicNetworkControlElement * ctr,
											   unsigned int numberParallelPumps) :
	HNAbstractPowerLimitedPumpModel(fluid.m_para[NANDRAD::HydraulicFluid::P_Density].value, component, numberParallelPumps),
	m_id(id),
	m_controlElement(ctr)
{
	// initialize value reference to pressure head, pointer will be updated for given schedules in setInputValueRefs()
	m_pressureHeadRef = &component.m_para[NANDRAD::HydraulicNetworkComponent::P_PressureHead].value;
}


double HNConstantPressurePump::systemFunction(double mdot, double p_inlet, double p_outlet) const {
	double pressureHead = *m_pressureHeadRef;
	// if pump is turned off, it should cause a large pressure drop
	if (!m_pumpIsOn) {
		mdot = mdot / m_numberParallelPumps;
		return p_inlet - p_outlet - (mdot * std::abs(mdot) * 1e10);
	}
	// if pump is on (or no controller is used): we apply the normal pressure head
	else {
		double maxPressureHead = maximumPressureHead(mdot);
		if (pressureHead > maxPressureHead)
			pressureHead = maxPressureHead;
		return p_inlet - p_outlet + pressureHead;
	}
}


void HNConstantPressurePump::partials(double /*mdot*/, double /*p_inlet*/, double /*p_outlet*/,
							 double & df_dmdot, double & df_dp_inlet, double & df_dp_outlet) const
{
	// partial derivatives of the system function to pressures are constants
	df_dp_inlet = 1;
	df_dp_outlet = -1;
	df_dmdot = 0;
}


void HNConstantPressurePump::inputReferences(std::vector<InputReference> & inputRefs) const {
	InputReference inputRef;
	if (m_controlElement != nullptr) {
		if (m_controlElement->m_controlledProperty == NANDRAD::HydraulicNetworkControlElement::CP_PumpOperation) {
			inputRef.m_id = m_followingflowElementId;
			inputRef.m_referenceType = NANDRAD::ModelInputReference::MRT_NETWORKELEMENT;
			inputRef.m_name.m_name = "FlowElementHeatLoss";
			inputRef.m_required = true;
			inputRefs.push_back(inputRef);
		}
	}
	// Note: this is an automatic override and could lead to problems. However, it is explicitely documented and
	//       a warning is added about this in the model description.
	inputRef.m_referenceType = NANDRAD::ModelInputReference::MRT_NETWORKELEMENT;
	inputRef.m_name = std::string("PressureHeadSchedule");
	inputRef.m_required = false;
	inputRef.m_id = m_id;
	inputRefs.push_back(inputRef);
}


void HNConstantPressurePump::setInputValueRefs(std::vector<const double *>::const_iterator & resultValueRefIt) {
	if (m_controlElement != nullptr) {
		if (m_controlElement->m_controlledProperty == NANDRAD::HydraulicNetworkControlElement::CP_PumpOperation){
			m_followingElementHeatLossRef = *resultValueRefIt;
			++resultValueRefIt;
		}
	}
	if (*resultValueRefIt != nullptr){
		m_pressureHeadRef = *resultValueRefIt; // optional, may be nullptr
	}
	++resultValueRefIt;
}

void HNConstantPressurePump::modelQuantities(std::vector<QuantityDescription> & quantities) const{
	quantities.push_back(QuantityDescription("ElectricalPower", "W", "Current electrical power demand of pump", false));
	quantities.push_back(QuantityDescription("PumpEfficiency", "---", "Current efficiency of pump", false));
}

void HNConstantPressurePump::modelQuantityValueRefs(std::vector<const double *> & valRefs) const{
	valRefs.push_back(&m_electricalPower);
	valRefs.push_back(&m_efficiency);
}

void HNConstantPressurePump::updateResults(double mdot, double p_inlet, double p_outlet){
	m_efficiency = efficiency(mdot, p_outlet - p_inlet);
	m_electricalPower = electricalPower(mdot, p_outlet - p_inlet, m_efficiency);
}


void HNConstantPressurePump::setTime(double /*t*/) {
	// This function implements the hysteresis behaviour of the OnOff-controlled pump:
	// if heat loss of next element is below 0.9*threshold: we switch off, if it is above 1.1*threshold: we switch on, in any other case: we keep current state
	// Note: if there is no controller or an invalid controlled property, the pump will never be turned off, we don't need to handle that case.
	//
	// Note: we update the controller operation state in setTime(), as opposed to stepCompleted(), because the input signal in m_followingElementHeatLossRef is
	//       mostly a purely time-dependent spline value.
	if (m_controlElement != nullptr) {
		if (m_controlElement->m_controlledProperty == NANDRAD::HydraulicNetworkControlElement::CP_PumpOperation) {
			const double & heatLossThreshold =
					m_controlElement->m_para[NANDRAD::HydraulicNetworkControlElement::P_HeatLossOfFollowingElementThreshold].value;
			if (std::abs(*m_followingElementHeatLossRef) < 0.9 * heatLossThreshold)
				m_pumpIsOn = false;
			else if (std::abs(*m_followingElementHeatLossRef) > 1.1 * heatLossThreshold)
				m_pumpIsOn = true;
		}
	}
}




// *** HNConstantMassFluxPump ***

HNConstantMassFluxPump::HNConstantMassFluxPump(unsigned int id, const NANDRAD::HydraulicNetworkComponent & component):
	m_id(id)
{
	// initialize mass flux
	m_massFluxRef = &component.m_para[NANDRAD::HydraulicNetworkComponent::P_MassFlux].value;
}


void HNConstantMassFluxPump::modelQuantities(std::vector<QuantityDescription> & quantities) const {
	quantities.push_back(QuantityDescription("PumpPressureHead","Pa", "The calculated controlled pressure head of the pump", false));
}


void HNConstantMassFluxPump::modelQuantityValueRefs(std::vector<const double *> & valRefs) const {
	valRefs.push_back(&m_pressureHead);
}


void HNConstantMassFluxPump::inputReferences(std::vector<InputReference> &inputRefs) const {
	InputReference ref;
	ref.m_id = m_id;
	ref.m_referenceType = NANDRAD::ModelInputReference::MRT_NETWORKELEMENT;
	ref.m_name.m_name = "MassFluxSchedule";
	ref.m_required = false;
	inputRefs.push_back(ref);
}


void HNConstantMassFluxPump::setInputValueRefs(std::vector<const double *>::const_iterator & resultValueRefIt) {
	// overwrite scheduled mass flux
	if(*resultValueRefIt != nullptr)
		m_massFluxRef = *resultValueRefIt;
	++resultValueRefIt;
}


double HNConstantMassFluxPump::systemFunction(double mdot, double /*p_inlet*/, double /*p_outlet*/) const {
	// systemFunction() is expected to return a value in the magnitude of typical pressure differences in network
	// Hence, we scale the mass flux up to have an equally scaled response value.
	return (mdot - *m_massFluxRef) * MASS_FLUX_SCALE;
}


void HNConstantMassFluxPump::partials(double /*mdot*/, double /*p_inlet*/, double /*p_outlet*/,
									  double & df_dmdot, double & df_dp_inlet, double & df_dp_outlet) const
{
	df_dmdot = 1;
	df_dp_inlet = 0.0;
	df_dp_outlet = 0.0;
}


void HNConstantMassFluxPump::updateResults(double /*mdot*/, double p_inlet, double p_outlet) {
	m_pressureHead = p_outlet - p_inlet;
}




// *** HNControlledPump ***

HNControlledPump::HNControlledPump(const NANDRAD::HydraulicNetworkElement & e,
								   const NANDRAD::HydraulicFluid & fluid, const std::vector<unsigned int> * networkElementIds,
								   const std::vector<double> * networkPressureDifferences, unsigned int numberParallelPumps) :
	HNAbstractPowerLimitedPumpModel(fluid.m_para[NANDRAD::HydraulicFluid::P_Density].value, *e.m_component, numberParallelPumps),
	m_controlElement(e.m_controlElement),
	m_id(e.m_id),
	m_observedPressureDiffElementIdMap(e.m_observedPressureDiffElementIds.m_values),
	m_networkElementIds(networkElementIds),
	m_networkPressureDifferences(networkPressureDifferences)
{
	// initialize setpoint references, in case of scheduled setpoints pointer will be updated in setInputValueRefs()
	m_temperatureDifferenceSetpointRef = &m_controlElement->m_para[NANDRAD::HydraulicNetworkControlElement::P_TemperatureDifferenceSetpoint].value;
	m_massFluxSetpointRef = &m_controlElement->m_para[NANDRAD::HydraulicNetworkControlElement::P_MassFluxSetpoint].value;
	m_pressureDifferenceSetpointRef = &m_controlElement->m_para[NANDRAD::HydraulicNetworkControlElement::P_PressureDifferenceSetpoint].value;
	// initialize pressure difference refs for PressureDifferenceWorstpoint controller
	if (m_controlElement->m_controlledProperty == NANDRAD::HydraulicNetworkControlElement::CP_PressureDifferenceWorstpoint)
		m_observedPressureDifferenceRefs.resize(m_observedPressureDiffElementIdMap.size());

	// add controller object
	switch (m_controlElement->m_controllerType) {
		case NANDRAD::HydraulicNetworkControlElement::CT_PController: {
			PController *cont = new PController();
			cont->m_kP = m_controlElement->m_para[NANDRAD::HydraulicNetworkControlElement::P_Kp].value;
			m_controller = cont;
		} break;
		case NANDRAD::HydraulicNetworkControlElement::CT_PIController: {
			PIController *cont = new PIController();
			cont->m_kP = m_controlElement->m_para[NANDRAD::HydraulicNetworkControlElement::P_Kp].value;
			cont->m_kI = m_controlElement->m_para[NANDRAD::HydraulicNetworkControlElement::P_Ki].value;
			m_controller = cont;
		} break;
		case NANDRAD::HydraulicNetworkControlElement::CT_PIDController: {
			PIDController *cont = new PIDController();
			cont->m_kP = m_controlElement->m_para[NANDRAD::HydraulicNetworkControlElement::P_Kp].value;
			cont->m_kI = m_controlElement->m_para[NANDRAD::HydraulicNetworkControlElement::P_Ki].value;
			cont->m_kD = m_controlElement->m_para[NANDRAD::HydraulicNetworkControlElement::P_Kd].value;
			m_controller = cont;
		} break;
		case NANDRAD::HydraulicNetworkControlElement::CT_OnOffController: // not a valid combination
		case NANDRAD::HydraulicNetworkControlElement::NUM_CT:
			break;
	}
	IBK_ASSERT(m_controller != nullptr);
}


HNControlledPump::~HNControlledPump() {
	delete m_controller;

}


void HNControlledPump::modelQuantities(std::vector<QuantityDescription> &quantities) const {
	quantities.push_back(QuantityDescription("PumpPressureHead","Pa", "The calculated controlled pressure head of the pump", false));
	quantities.push_back(QuantityDescription("ElectricalPower", "W", "Current electrical power demand of pump", false));
	quantities.push_back(QuantityDescription("PumpEfficiency", "---", "Current efficiency of pump", false));
	IBK_ASSERT(m_controller != nullptr);
	quantities.push_back(QuantityDescription("ControllerErrorValue","---", "The calculated controller error for pump", false));
	if (m_controlElement->m_controlledProperty == NANDRAD::HydraulicNetworkControlElement::CP_TemperatureDifferenceOfFollowingElement)
		quantities.push_back(QuantityDescription("TemperatureDifference","K", "The difference between inlet and outlet temperature", false));
	if (m_controlElement->m_controlledProperty == NANDRAD::HydraulicNetworkControlElement::CP_PressureDifferenceWorstpoint) {
		quantities.push_back(QuantityDescription("PressureDifferenceAtWorstpoint","Pa", "The pressure difference at worst point in network", false));
		quantities.push_back(QuantityDescription("WorstpointNodeId","---", "The VICUS Node Id of the worst point", false));
	}

}


void HNControlledPump::modelQuantityValueRefs(std::vector<const double*> &valRefs) const {
	valRefs.push_back(&m_pressureHead);
	valRefs.push_back(&m_electricalPower);
	valRefs.push_back(&m_efficiency);
	valRefs.push_back(&m_controllerError);
	if (m_controlElement->m_controlledProperty == NANDRAD::HydraulicNetworkControlElement::CP_TemperatureDifferenceOfFollowingElement)
		valRefs.push_back(&m_temperatureDifference);
	if (m_controlElement->m_controlledProperty == NANDRAD::HydraulicNetworkControlElement::CP_PressureDifferenceWorstpoint) {
		valRefs.push_back(&m_pressureDifferenceWorstpoint);
		valRefs.push_back(&m_nodeIdWorstpoint);
	}
}


void HNControlledPump::inputReferences(std::vector<InputReference> & inputRefs) const {
	IBK_ASSERT(m_controller != nullptr);

	switch (m_controlElement->m_controlledProperty) {

		case NANDRAD::HydraulicNetworkControlElement::CP_TemperatureDifferenceOfFollowingElement: {
			InputReference ref;
			ref.m_id = m_followingflowElementId;
			ref.m_referenceType = NANDRAD::ModelInputReference::MRT_NETWORKELEMENT;
			ref.m_name.m_name = "FluidTemperature";
			ref.m_required = true;
			inputRefs.push_back(ref);
			// if we have a scheduled temperature difference setpoint, also generate input reference for
			// the scheduled value
			if (m_controlElement->m_modelType == NANDRAD::HydraulicNetworkControlElement::MT_Scheduled) {
				InputReference ref;
				ref.m_id = m_id;
				ref.m_referenceType = NANDRAD::ModelInputReference::MRT_NETWORKELEMENT;
				ref.m_name.m_name = "TemperatureDifferenceSetpointSchedule";
				ref.m_required = true;
				inputRefs.push_back(ref);
			}
		} break;

		case NANDRAD::HydraulicNetworkControlElement::CP_MassFlux: {
			// only create input reference for scheduled variant
			if (m_controlElement->m_modelType == NANDRAD::HydraulicNetworkControlElement::MT_Scheduled) {
				InputReference ref;
				ref.m_id = m_id;
				ref.m_referenceType = NANDRAD::ModelInputReference::MRT_NETWORKELEMENT;
				ref.m_name.m_name = "MassFluxSetpointSchedule";
				ref.m_required = true;
				inputRefs.push_back(ref);
			}
		} break;

		// other combinations are not supported
		case NANDRAD::HydraulicNetworkControlElement::CP_TemperatureDifference:
		case NANDRAD::HydraulicNetworkControlElement::CP_ThermostatValue:
		case NANDRAD::HydraulicNetworkControlElement::CP_PumpOperation:
		case NANDRAD::HydraulicNetworkControlElement::CP_PressureDifferenceWorstpoint:
		case NANDRAD::HydraulicNetworkControlElement::NUM_CP:
		break;
	}
}


void HNControlledPump::setInputValueRefs(std::vector<const double*>::const_iterator & resultValueRefs) {
	IBK_ASSERT(m_controller != nullptr);

	switch (m_controlElement->m_controlledProperty) {
		case NANDRAD::HydraulicNetworkControlElement::CP_TemperatureDifferenceOfFollowingElement :
			// now store the pointer returned for our input ref request and advance the iterator by one
			m_followingFlowElementFluidTemperatureRef = *(resultValueRefs++); // Fluid temperature of following element
			// scheduled variant?
			if (m_controlElement->m_modelType == NANDRAD::HydraulicNetworkControlElement::MT_Scheduled)
				m_temperatureDifferenceSetpointRef = *(resultValueRefs++);
		break;
		case NANDRAD::HydraulicNetworkControlElement::CP_MassFlux:
			// scheduled variant?
			if (m_controlElement->m_modelType == NANDRAD::HydraulicNetworkControlElement::MT_Scheduled)
				m_massFluxSetpointRef = *(resultValueRefs++);
		break;

		// Collect references to pressure differences
		// Note: These are NO input references, but at this point the network is setup sufficiently, so we do that here
		case NANDRAD::HydraulicNetworkControlElement::CP_PressureDifferenceWorstpoint: {
			// we go through all observed element groups / sub networks
			unsigned int subNetworkCounter = 0;
			for (auto it=m_observedPressureDiffElementIdMap.begin(); it!=m_observedPressureDiffElementIdMap.end(); ++it) {

				// for each element of that group / sub network: add pointer to pressure difference
				const std::vector<unsigned int> &ids = it->second;
				for (unsigned int i=0; i<ids.size(); ++i) {
					std::vector<unsigned int>::const_iterator fIt = std::find(m_networkElementIds->begin(), m_networkElementIds->end(), ids[i]);
					// invalid ID?
					IBK_ASSERT(fIt != m_networkElementIds->end());
					// set reference to pressure difference (vector has been resized in the constructor already)
					unsigned int pos = (unsigned int) std::distance(m_networkElementIds->begin(), fIt);
					m_observedPressureDifferenceRefs[subNetworkCounter].push_back(&m_networkPressureDifferences->at(pos));
				}
				++subNetworkCounter;
			}

		} break;

		// other combinations are not supported
		case NANDRAD::HydraulicNetworkControlElement::CP_TemperatureDifference:
		case NANDRAD::HydraulicNetworkControlElement::CP_ThermostatValue:
		case NANDRAD::HydraulicNetworkControlElement::CP_PumpOperation:
		case NANDRAD::HydraulicNetworkControlElement::NUM_CP: ;
	}
}


void HNControlledPump::dependencies(const double * mdot, std::vector<std::pair<const double *, const double *> > & resultInputDependencies) const {
	IBK_ASSERT(m_controller != nullptr);
	switch (m_controlElement->m_controlledProperty) {
		case NANDRAD::HydraulicNetworkControlElement::CP_TemperatureDifferenceOfFollowingElement:
			resultInputDependencies.push_back(std::make_pair(mdot, m_fluidTemperatureRef) );
			resultInputDependencies.push_back(std::make_pair(mdot, m_followingFlowElementFluidTemperatureRef) );
		break;
		case NANDRAD::HydraulicNetworkControlElement::CP_MassFlux:
			resultInputDependencies.push_back(std::make_pair(mdot, m_massFluxSetpointRef) );
		break;
		case NANDRAD::HydraulicNetworkControlElement::CP_PressureDifferenceWorstpoint:
			resultInputDependencies.push_back(std::make_pair(mdot, m_pressureDifferenceSetpointRef) );
		break;

		case NANDRAD::HydraulicNetworkControlElement::CP_TemperatureDifference:
		case NANDRAD::HydraulicNetworkControlElement::CP_ThermostatValue:
		case NANDRAD::HydraulicNetworkControlElement::CP_PumpOperation:
		case NANDRAD::HydraulicNetworkControlElement::NUM_CP: ;
	}
}


double HNControlledPump::systemFunction(double mdot, double p_inlet, double p_outlet) const {
	double deltaP = p_inlet - p_outlet;
	double pressHead = pressureHeadControlled(mdot);
	return deltaP + pressHead;
}


void HNControlledPump::partials(double mdot, double p_inlet, double p_outlet,
							 double & df_dmdot, double & df_dp_inlet, double & df_dp_outlet) const
{
	df_dp_inlet = 1;
	df_dp_outlet = -1;
	// generic DQ approximation of partial derivative
	const double EPS = 1e-5; // in kg/s
	double f_eps = systemFunction(mdot+EPS, p_inlet, p_outlet);
	double f = systemFunction(mdot, p_inlet, p_outlet);
	df_dmdot = (f_eps - f)/EPS;
}


double HNControlledPump::pressureHeadControlled(double mdot) const {

	double e = 0;	// deviation of controlled property

	// calculate zetaControlled value for valve
	switch (m_controlElement->m_controlledProperty) {

		case NANDRAD::HydraulicNetworkControlElement::CP_TemperatureDifferenceOfFollowingElement: {
			double temperatureDifference;
			// compute temperature difference of the following element. We already know that the node between this
			// and the following element is not connected to any other flow element

			// Note: temperatureDifference can be > 0 or < 0, depending wether the following element extracts or adds heat
			temperatureDifference = (*m_fluidTemperatureRef - *m_followingFlowElementFluidTemperatureRef);

			// for positive dT-setpoints, the controller error should be positive when the current dT is too high, so mass flux will be increased
			if (*m_temperatureDifferenceSetpointRef > 0)
				e = temperatureDifference - *m_temperatureDifferenceSetpointRef;
			// for negative dT-setpoints, the controller error should also be positive when the current dT is too high, so mass flux will be increased
			else
				e = *m_temperatureDifferenceSetpointRef - temperatureDifference;

			// anti-windup of PI-controller: if we get very small mass fluxes, this means the heat loss of the
			// following element is very small. We dont want to sum up that error, so we set the integral to 0.
			if (mdot / m_numberParallelPumps < 1e-5)
				m_controller->resetErrorIntegral();
		} break;

		case NANDRAD::HydraulicNetworkControlElement::CP_MassFlux: {
			// external reference or constant parameter
			const double mdotSetpoint = *m_massFluxSetpointRef;
			// setpoint 0 returns 0
			if (mdotSetpoint == 0.0)
				return 0.0;
			// compute controller error
			e = mdotSetpoint - mdot / m_numberParallelPumps;
			// if e is > 0 if our mass flux is below the limit (we need to increase mass flux by increasing pressure head)
		} break;

		case NANDRAD::HydraulicNetworkControlElement::CP_PressureDifferenceWorstpoint: {
			// external reference or constant parameter
			IBK_ASSERT(m_pressureDifferenceSetpointRef != nullptr);
			const double dpSetpoint = *m_pressureDifferenceSetpointRef;
			double nodeId;
			double minPressureDifference = pressureDifferenceAtWorstPoint(nodeId);
			// controller error
			e = dpSetpoint - minPressureDifference;
		} break;

		// not possible combinations
		case NANDRAD::HydraulicNetworkControlElement::CP_TemperatureDifference:
		case NANDRAD::HydraulicNetworkControlElement::CP_ThermostatValue:
		case NANDRAD::HydraulicNetworkControlElement::CP_PumpOperation:
		case NANDRAD::HydraulicNetworkControlElement::NUM_CP: ;
	}

	// set min / max values for clipping
	// if temperature difference is smaller than the required difference (negative e), our mass flux is too large,
	// we stop it by setting pressHeadControlled = 0
	// NOTE: we DONT do this for option CP_MassFlux !!!
	if (m_controlElement->m_controlledProperty == NANDRAD::HydraulicNetworkControlElement::CP_TemperatureDifferenceOfFollowingElement ||
		m_controlElement->m_controlledProperty == NANDRAD::HydraulicNetworkControlElement::CP_PressureDifferenceWorstpoint)
		m_controller->m_controlValueMinimum = 0;
	// maximum pressure head depends on mass flux
	m_controller->m_controlValueMaximum = maximumPressureHead(mdot);

	// update controller value and obtain result
	m_controller->update(e);

	return m_controller->m_controlValue;
}


double HNControlledPump::pressureDifferenceAtWorstPoint(double & worstPointNodeId) const {

	// calculate minimum pressure difference of observed sub stations
	std::vector<double> pressureDifferenceSums(m_observedPressureDifferenceRefs.size(), 0);
	for (unsigned int i=0; i<m_observedPressureDifferenceRefs.size(); ++i) {
		for (const double * x: m_observedPressureDifferenceRefs[i])
			pressureDifferenceSums[i] += *x;
	}
	IBK_ASSERT(pressureDifferenceSums.size()>0); // to make sure we dont get a nullptr from the min_element
	double minPressureDifference = *std::min_element(pressureDifferenceSums.begin(), pressureDifferenceSums.end());
	// get VICUS node id with lowest pressure difference from map (it is stored as a string) and try to convert it to int
	int minPressureDifferenceIndex = std::min_element(pressureDifferenceSums.begin(), pressureDifferenceSums.end()) - pressureDifferenceSums.begin();
	auto it = m_observedPressureDiffElementIdMap.begin();
	std::advance(it, minPressureDifferenceIndex);
	try {
		worstPointNodeId = (double)it->first;
	}  catch (...) {
		worstPointNodeId = NANDRAD::INVALID_ID;
	}
	return minPressureDifference;
}


void HNControlledPump::updateResults(double mdot, double p_inlet, double p_outlet) {
	m_efficiency = efficiency(mdot, p_outlet - p_inlet);
	m_electricalPower = electricalPower(mdot, p_outlet - p_inlet, m_efficiency);
	m_pressureHead = pressureHeadControlled(mdot);
	m_controllerError = m_controller->m_errorValue;
	if (m_controlElement->m_controlledProperty == NANDRAD::HydraulicNetworkControlElement::CP_TemperatureDifferenceOfFollowingElement)
		m_temperatureDifference = (*m_fluidTemperatureRef - *m_followingFlowElementFluidTemperatureRef);
	if (m_controlElement->m_controlledProperty == NANDRAD::HydraulicNetworkControlElement::CP_PressureDifferenceWorstpoint)
		m_pressureDifferenceWorstpoint = pressureDifferenceAtWorstPoint(m_nodeIdWorstpoint);
}


void HNControlledPump::stepCompleted(double t) {
	if (m_controller == nullptr)
		return;

	m_controller->stepCompleted(t);

//	// Anti-windup of PI-controller: For high controller errors (e.g. >70 % of set point), i.e. when the current value is
//	// very far from the setpoint, we don't use the integral part. This avoids an increase (windup) of the integral during times when
//	// there is no heat flux and the temperature difference setpoint can not be reached.
//	const double relControllerErrorIntegratorReset = m_controlElement->m_para[NANDRAD::HydraulicNetworkControlElement::P_RelControllerErrorForIntegratorReset].value;
//	if (relControllerErrorIntegratorReset > 0) {
//		switch (m_controlElement->m_controlledProperty ) {
//			case NANDRAD::HydraulicNetworkControlElement::CP_PressureDifferenceWorstpoint:
//				if (m_controller->m_errorValue > relControllerErrorIntegratorReset * *m_pressureDifferenceSetpointRef)  {
//					m_controller->resetErrorIntegral();
//				} break;
//			case NANDRAD::HydraulicNetworkControlElement::CP_TemperatureDifference:
//			case NANDRAD::HydraulicNetworkControlElement::CP_TemperatureDifferenceOfFollowingElement: {
////					if (m_controller->m_errorValue > relControllerErrorIntegratorReset * *m_temperatureDifferenceSetpointRef)  {
////						m_controller->resetErrorIntegral();
////					}
////				}
//				break;
//			case NANDRAD::HydraulicNetworkControlElement::CP_MassFlux:
//				// TODO anti-windup for mass flux control ?
//				break;
//			case NANDRAD::HydraulicNetworkControlElement::CP_ThermostatValue:
//			case NANDRAD::HydraulicNetworkControlElement::CP_PumpOperation:

//			case NANDRAD::HydraulicNetworkControlElement::NUM_CP:
//				break; // just for compiler
//		}
//	}
//}

}


std::size_t HNControlledPump::serializationSize() const {
	if (m_controller == nullptr )
		return 0;

	return m_controller->serializationSize();
}


void HNControlledPump::serialize(void *& dataPtr) const {
	if (m_controller == nullptr )
		return;
	// serialize controller and shift data pointer
	m_controller->serialize(dataPtr);
}


void HNControlledPump::deserialize(void *& dataPtr) {
	if (m_controller == nullptr )
		return;
	// deserialize controller and shift data pointer
	m_controller->deserialize(dataPtr);
}



// *** HNVariablePressureHeadPump ***

HNVariablePressureHeadPump::HNVariablePressureHeadPump(unsigned int id, const NANDRAD::HydraulicNetworkComponent &component,
													   const NANDRAD::HydraulicFluid & fluid, unsigned int numberParallelPumps) :
	HNAbstractPowerLimitedPumpModel(fluid.m_para[NANDRAD::HydraulicFluid::P_Density].value, component, numberParallelPumps),
	m_id(id)
{
	// initialize value reference to pressure head, pointer will be updated for given schedules in setInputValueRefs()
	m_designPressureHead = component.m_para[NANDRAD::HydraulicNetworkComponent::P_DesignPressureHead].value;
	m_minimumPressureHead = m_designPressureHead * component.m_para[NANDRAD::HydraulicNetworkComponent::P_PressureHeadReductionFactor].value;
	m_designMassFlux = component.m_para[NANDRAD::HydraulicNetworkComponent::P_DesignMassFlux].value;
}


double HNVariablePressureHeadPump::systemFunction(double mdot, double p_inlet, double p_outlet) const {
	return p_inlet - p_outlet + pressureHead(mdot);
}


void HNVariablePressureHeadPump::partials(double /*mdot*/, double /*p_inlet*/, double /*p_outlet*/,
							 double & df_dmdot, double & df_dp_inlet, double & df_dp_outlet) const
{
	// partial derivatives of the system function to pressures are constants
	df_dp_inlet = 1;
	df_dp_outlet = -1;
	df_dmdot = 0;
}


void HNVariablePressureHeadPump::modelQuantities(std::vector<QuantityDescription> &quantities) const {
	quantities.push_back(QuantityDescription("PumpPressureHead","Pa", "The calculated controlled pressure head of the pump", false));
	quantities.push_back(QuantityDescription("ElectricalPower", "W", "Current electrical power demand of pump", false));
	quantities.push_back(QuantityDescription("PumpEfficiency", "---", "Current efficiency of pump", false));
}


void HNVariablePressureHeadPump::modelQuantityValueRefs(std::vector<const double *> &valRefs) const {
	valRefs.push_back(&m_pressureHead);
	valRefs.push_back(&m_electricalPower);
	valRefs.push_back(&m_efficiency);
}


void HNVariablePressureHeadPump::updateResults(double mdot, double p_inlet, double p_outlet) {
	m_pressureHead = pressureHead(mdot);
	m_efficiency = efficiency(mdot, p_outlet - p_inlet);
	m_electricalPower = electricalPower(mdot, p_outlet - p_inlet, m_efficiency);
}


double HNVariablePressureHeadPump::pressureHead(double mdot) const {
	// slope of linear dp-v curve
	double slope = (m_designPressureHead - m_minimumPressureHead) / m_designMassFlux;

	// for mass fluxes < 10% design mass flux, we keep a constant pressure head
	double mdot_cut = 0.1 * m_designMassFlux;
	double pressureHead;
	// If our mass flux falls below the threshold mdot_cut, we return a constant pressure head.
	// However, we cannot return the pressure head p(mdot=0) = minimumPressureHead, because our mdot > 0
	// Hence, we just return the linearly interpolated pressure head p(mdot=mdot_cut)
	if (mdot / m_numberParallelPumps < mdot_cut)
		return m_minimumPressureHead + slope * mdot_cut; // = m_minimumPressureHead + (m_designPressureHead - m_minimumPressureHead) * 0.1;

	// linear dp-v curve
	pressureHead = m_minimumPressureHead + slope * mdot / m_numberParallelPumps;

	// clipping
	double pressHeadMax  = maximumPressureHead(mdot);
	if (pressureHead > pressHeadMax)
		pressureHead = pressHeadMax;

	return  pressureHead;
}


} // namespace NANDRAD_MODEL
